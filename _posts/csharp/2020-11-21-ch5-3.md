---
title:  "Chapter 5-3. 객체 지향 : 상속성, 은닉성" 

categories:
  -  C Sharp
tags:
  - [Programming, C Sharp]

toc: true
toc_sticky: true

date: 2020-11-21
last_modified_at: 2020-11-21
---

인프런에 있는 Rookiss님의 강의 **Part1: C# 기초 프로그래밍 입문** 를 듣고 정리한 필기입니다. 😀  
{: .notice--warning}
 
## 👱‍♀️ 상속성

> 코드의 재사용성

- 부모 클래스 👉 Player
  - 직업에 상관없이 플레이어라면 모두 가지고 잇는 공통된 속성과 기능을 부모클래스로 묶는다. 
- 자식 클래스 👉 Mage, Aracher, Knight 
  - 이 클래스들은 Player를 상속받으므로 플레이어라면 모두 갖고 있는 공통 멤버들을 다시 필드에 명시해줄 필요가 없다.
  - 이런 부분들은 Player 상속으로 해결하고 법사, 궁수, 전사들만의!!! 고유의 속성과 기능을 추가해주면 되는 식이다.

자식 클래스에서 멤버 필드에 직접 명시해주지 않더라도 상속만 하면 자동으로 부모의 멤버들도 가지게 된다. 👉 **코드의 재사용성**

> 부모 생성자가 먼저 호출 된다.

당연히 생성자도 함수이므로 부모 생성자를 자식 클래스에서 상속을 받고, 언제나 부모 생성자를 먼저 호출한다. 개발자가 명시하지 않으면 부모 클래스의 디폴트 생성자가 호출되며, `base(123)` 이런식으로 `base`를 사용하여 원하는 종류의 부모 생성자를 직접 호출할 수도 있다. `this`는 호출된 객체를 가리키는 것이라면(나) `base`는 부모로부터 상속받은 멤버들에 접근할 수 있는 키워드다.

- <u>개발자가 명시하지 않으면 부모 클래스의 디폴트 생성자가 호출된다.</u>
  - 부모 클래스에 생성자 정의가 아예 없거나(이 경우 컴파일러가 자동으로 만들어 줌) 혹은 디폴트 생성자 정의가 되어 있다면 문제가 되지 않지만
  - 부모 클래스에 매개 변수가 있는 생성자들은 있는데 디폴트 생성자 정의는 없는 경우에는 컴파일러가 자동으로 만들어 주지 않는다.
    - 따라서 이런 경우에는 다른 부모 생성자 호출을 직접 명시하지 않으면 컴파일 에러가 난다. 부모 클래스의 디폴트 생성자를 정의해주거나, 혹은 개발자가 매개 변수가 있는 특정 부모 생성자를 직접 호출시켜 주어야 한다.
    
  ```c#
    class Player
    {
        protected int hp = 0;

        protected Player(int hp) { this.hp = hp; }
    }

    class Knight : Player
    {
        public Knight()  // ❌ 컴파일 에러 발생 👉 부모인 Player에 디폴트 생성자가 없어 호출할 수 없다. 
        {

        }
    }

    class Mage : Player
    {
        publi Mage() : base(30)  // ⭕ 문제 되지 않는다. 특정한 부모 생성자를 직접 호출해주었기 때문에
        {

        }
    }
  ``` 
  ```c#
    class Player
    {
        protected int hp = 0;
    }

    class Knight : Player
    {
        public Knight() // ⭕ 문제 되지 않는다. 부모 생성자 딱히 정의된게 없기 때문에 디폴트 부모 생성자를 컴파일러가 자동으로 만들어 호출해주기 때문.
        {

        }
    }
  ```

<br>

## 👱‍♀️ 은닉성

> 보안. 숨기기! 외부에서 쉽게 접근 되고 함부로 고치면 안되는 정보라면 접근 한정자를 사용하여 보호 수준을 결정할 수 있다. 

- 접근 한정자
  - `public`
    - 외부에서 접근할 수 있음. 
  - `protected`
    - 외부에선 안되지만 내 자식들은 접근 할 수 있음.
  - `private` 👉 디폴트
    - 나만 접근할 수 있음. 자식들도 접근 못 함.
    - getter, setter 같은 public 접근 함수를 따로 만들어서 간접 접근함.
      - 이렇게 하는 이유! ✨ 외부에서 직접 접근하여 `player.hp = 100` 이러고 다니면.. 유지 보수시 `hp` 멤버에 언제 언제 접근했는지 일일이 다 알아내기가 힘들다. 그러나 private으로 해두고 접근 함수를 사용하여 접근하면 그냥 setter 함수 내부에만 🔴 중단점을 걸어나오면 알아서 이 부분을 실행한 *호출 스택* 이 나오므로 매우 편하다.

<br>

## 👱‍♀️ 다형성

다음 포스트 참고!

***
<br>

    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}