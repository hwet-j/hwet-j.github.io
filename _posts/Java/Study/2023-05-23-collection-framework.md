---
title:  "[Java] 컬렉션 프레임워크"  
excerpt: "컬렉션 프레임워크는 배열과 어떻게 다를까?"

categories: # 분류하고싶은 카테고리 입력
  - Java
tags:     # 중요 키워드
  - [Term]

toc: true
toc_sticky: true

author: Hwet

date: 2023-05-23
last_modified_at: 2023-05-23
---

인터넷에서 검색하여 여러가지를 참고하여 정리하였습니다.    
[참고1](http://www.tcpschool.com/java/java_collectionFramework_concept)
[참고2](https://hudi.blog/java-collection-framework-1/)
[참고3](https://coding-factory.tistory.com/550)
{: .notice--warning}

## 컬렉션 프레임워크

### 컬렉션 프레임워크(collection framework)란?

자바에서 컬렉션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미한다.

즉, 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화 하여 클래스로 구현해 놓은 것입니다.

또한, `데이터 삽입, 탐색, 정렬등 편리한 API를 제공`한다. 이러한 이점으로 배열보다 적절한 컬렉션을 선택해 사용하는 것을 권장한다.

컬렉션 프레임워크는 자바의 인터페이스를 사용하여 구현됩니다.

#### 컬렉션 프레임워크의 장점

- List, Set, Map, Queue 등의 인터페이스를 제공하고, 이를 구현하는 클래스를 제공하여 일관된 API를 사용할 수 있다.
- `가변적인 저장 공간을 제공`한다. 고정적인 저장 공간을 제공하는 배열에 대비되는 특징이다.
- 자료구조, 알고리즘을 구현하기 위한 코드를 직접 작성하지않고, 이미 구현된 컬렉션 클래스를 목적에 맞게 사용하면 된다.


#### 프레임워크 vs 라이브러리 (간단한 차이점)

프레임워크와 라이브러리의 차이점은 `제어 흐름`의 권한이 어디에 있는가에 있다.

프레임워크의 경우에는 이미 만들어진 틀에서 동작하기 때문에 제어 흐름을 프레임워크가 가지고 있고 사용자는 그 안에서 필요한 코드를 작성하게됩니다.

라이브러리는 애플리케이션 코드의 흐름을 사용자가 직접 제어해야 합니다.

더 자세한 내용은 이후에 포스팅하겠습니다.

### 컬렉션 프레임워크 주요 인터페이스

- List : 인덱스 순서로 요소를 저장한다. 중복 데이터를 저장할 수 있다.
- Set : 순서가 없으며, 중복 데이터를 저장할 수 없다. 집합 연산을 제공한다.
- Map : Key-value 쌍으로 데이터를 저장하며, Key는 중복 저장 불가능하다. 순서가 없다. (Python의 Dictionary와 유사)
- Queue : 데이터가 저장된 순서대로 출력되는 선입선출(FIFO)의 구조를 갖는 선형 자료구조

List와 Set은 Collection 인터페이스를 상속받지만, 구조상의 차이로 Map 인터페이스는 별도로 정의됩니다.



#### List

List 컬렉션은 객체를 인덱스로 관리하기 때문에 저장하면 자동으로 인덱스가 부여되고 인덱스로 검색, 수정, 삭제할 수 있는 기능이 제공된다.

인덱스 내에는 객체 자체를 저장하는 것이 아니라 객체의 번지를 참조한다. 이때, 동일한 객체를 중복 저장하게 되면 동일한 번지를 참조하는 것이다.

List를 구현하는 대표적인 클래스에는 ArrayList, Vector, LinkedList 가 있다.

| 메서드                            | 기능                                           |
|--------------------------------|----------------------------------------------|
| boolean add(E e)               | 주어진 객체를 맨 끝에 추가합니다                           |
| void add(int index, E element) | 주어진 인덱스에 객체를 추가합니다. 단, 빈 인덱스가 존재하지 않도록 해야한다. |
| set(int index, E element)                          | 이미 저장된 인덱스의 객체를 주어진 객체로 바꿉니다.                |
| boolean contains(Object o)                          | 주어진 객체가 있는지에 대한 여부를 검색합니다.                   |
| E get(int index)                          | 주어진 인덱스에 저장된 객체를 리턴합니다                       |
| isEmpty()                          | 컬렉션(리스트)이 비어있는지 여부를 확인합니다.                   |
| int size()                          | 저장되어 있는 전체 객체 수를 리턴합니다.                      |
| E remove(int index)                          | 주어진 인덱스에 저장된 객체를 삭제합니다. (해당 객체를 리턴한다.)       |
| void clear()                          | 주어진 인덱스에 저장된 객체를 삭제합니다. (리턴값이 존재하지 않는다.)     |
| boolean remove(Object o)                          | 주어진 객체를 삭제합니다.                                         |


#### Set

Set 컬렉션은 저장 순서를 유지하지 않으며 순서가 없으므로 인덱스로 값을 가져오는 기능을 제공하지 않습니다.

또한, Set은 객체를 중복해서 저장할 수 없으며 null값 또한 한번만 저장됩니다.

Set은 인덱스로 값을 가져오는 메서드가 없고 반복자(Iterator)를 제공합니다.




***
<br>
    
    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}