---
title:  "[Java] 쓰레드, 프로세스"  
excerpt: "쓰레느는 무엇이고, 프로세스는 무엇인가?"

categories: # 분류하고싶은 카테고리 입력
  - Java
tags:     # 중요 키워드
  - [Term, Thread]

toc: true
toc_sticky: true

author: Hwet

date: 2023-05-25
last_modified_at: 2023-05-25
---

인터넷에서 검색하여 여러가지를 참고하여 정리하였습니다.    
[참고1](http://www.tcpschool.com/java/java_collectionFramework_concept)
[참고2](https://hudi.blog/java-collection-framework-1/)
[참고3](https://coding-factory.tistory.com/550)
{: .notice--warning}

## 컬렉션 프레임워크

### 컬렉션 프레임워크(collection framework)란?

자바에서 컬렉션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미한다.

즉, 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화 하여 클래스로 구현해 놓은 것입니다.

또한, `데이터 삽입, 탐색, 정렬등 편리한 API를 제공`한다. 이러한 이점으로 배열보다 적절한 컬렉션을 선택해 사용하는 것을 권장한다.

컬렉션 프레임워크는 자바의 인터페이스를 사용하여 구현됩니다.

#### 컬렉션 프레임워크의 장점

- List, Set, Map, Queue 등의 인터페이스를 제공하고, 이를 구현하는 클래스를 제공하여 일관된 API를 사용할 수 있다.
- `가변적인 저장 공간을 제공`한다. 고정적인 저장 공간을 제공하는 배열에 대비되는 특징이다.
- 자료구조, 알고리즘을 구현하기 위한 코드를 직접 작성하지않고, 이미 구현된 컬렉션 클래스를 목적에 맞게 사용하면 된다.


#### 프레임워크 vs 라이브러리 (간단한 차이점)

프레임워크와 라이브러리의 차이점은 `제어 흐름`의 권한이 어디에 있는가에 있다.

프레임워크의 경우에는 이미 만들어진 틀에서 동작하기 때문에 제어 흐름을 프레임워크가 가지고 있고 사용자는 그 안에서 필요한 코드를 작성하게됩니다.

라이브러리는 애플리케이션 코드의 흐름을 사용자가 직접 제어해야 합니다.

더 자세한 내용은 이후에 포스팅하겠습니다.

### 컬렉션 프레임워크 주요 인터페이스

- List : 인덱스 순서로 요소를 저장한다. 중복 데이터를 저장할 수 있다.
- Set : 순서가 없으며, 중복 데이터를 저장할 수 없다. 집합 연산을 제공한다.
- Map : Key-value 쌍으로 데이터를 저장하며, Key는 중복 저장 불가능하다. 순서가 없다. (Python의 Dictionary와 유사)
- Queue : 데이터가 저장된 순서대로 출력되는 선입선출(FIFO)의 구조를 갖는 선형 자료구조

List와 Set은 Collection 인터페이스를 상속받지만, 구조상의 차이로 Map 인터페이스는 별도로 정의됩니다.



#### List

List 컬렉션은 객체를 인덱스로 관리하기 때문에 저장하면 자동으로 인덱스가 부여되고 인덱스로 검색, 수정, 삭제할 수 있는 기능이 제공된다.

인덱스 내에는 객체 자체를 저장하는 것이 아니라 객체의 번지를 참조한다. 이때, 동일한 객체를 중복 저장하게 되면 동일한 번지를 참조하는 것이다.

대표적인 클래스에는 ArrayList, Vector, LinkedList이 있습니다.

| 메서드                            | 기능                                           |
|--------------------------------|----------------------------------------------|
| boolean add(E e)               | 주어진 객체를 맨 끝에 추가합니다                           |
| void add(int index, E element) | 주어진 인덱스에 객체를 추가합니다. 단, 빈 인덱스가 존재하지 않도록 해야한다. |
| set(int index, E element)      | 이미 저장된 인덱스의 객체를 주어진 객체로 바꿉니다.                |
| boolean contains(Object o)     | 주어진 객체가 있는지에 대한 여부를 검색합니다.                   |
| E get(int index)               | 주어진 인덱스에 저장된 객체를 리턴합니다                       |
| isEmpty()                      | 컬렉션(리스트)이 비어있는지 여부를 확인합니다.                   |
| int size()                     | 저장되어 있는 전체 객체 수를 리턴합니다.                      |
| E remove(int index)            | 주어진 인덱스에 저장된 객체를 삭제합니다. (해당 객체를 리턴한다.)       |
| void clear()                   | 주어진 인덱스에 저장된 객체를 삭제합니다. (리턴값이 존재하지 않는다.)     |
| boolean remove(Object o)       | 주어진 객체를 삭제합니다.                                         |

***

#### Set

Set 컬렉션은 저장 순서를 유지하지 않으며 순서가 없으므로 인덱스로 값을 가져오는 기능을 제공하지 않습니다.

또한, Set은 객체를 중복해서 저장할 수 없으며 null값 또한 한번만 저장됩니다.

Set은 인덱스로 값을 가져오는 메서드가 없고 반복자(Iterator)를 제공합니다.

대표적인 클래스로 HashSet, TreeSet이 있습니다.


| 메서드                        | 기능                                            |
|----------------------------|-----------------------------------------------|
| boolean add(E e)           | 주어진 객체를 저장 후 성공적이면 true를 중복 객체면 false를 리턴합니다. |
| boolean contains(Object o) | 주어진 객체가 저장되어있는지 여부를 리턴합니다.                    |
| Iterator<E> iterator()     | 저장된 객체를 한번씩 가져오는 반복자를 리턴합니다.                  |
| isEmpty()                  | 컬렉션이 비어있는지 조사합니다.                             |
| int Size()                 | 저장되어 있는 전체 객체수를 리턴합니다.                        |
| void clear()               | 저장된 모든 객체를 삭제합니다.                             |
| boolean remove(Object o)   | 주어진 객체를 삭제합니다. (리턴값 존재)                       |

*** 

#### Map

키(key)와 값(value)로 구성된 객체를 저장하는 구조로 파이썬의 딕셔너리를 떠올리면 된다.

키는 중복으로 저장될 수없으며, 중복된 key가 들어오면 key에 해당하는 기존값(value)은 사라지고 새로운 값(value)으로 덮어씌워진다.

대표적인 클래스로 HashMap, Hashtable, TreeMap, LinkedHashMap이 있습니다.


| 메서드                                 | 기능                                           |
|-------------------------------------|----------------------------------------------|
| V put(K Key, V value)               | 주어진 키와 값을 추가하여 저장되면 값을 리턴합니다.                          |
| boolean containsKey(Object Key)     | 주어진 키가 있는지 확인합니다. |
| boolean containsValue(Object value) | 주어진 값이 있는지 확인합니다.               |
| Set<Map.Entry<K,V>> entrySet()      | 모든 Map.Entry 객체를 Set에 담아 리턴합니다.                   |
| Set<K> keySet()                     | 모든 키를 Set객체에 담아서 리턴합니다.                      |
| V get(Object key)                   | 주어진 키에 있는 값을 리턴합니다.                   |
| boolean isEmpty()                   | 컬렉션이 비어있는지 조사합니다.                     |
| int Size()                          | 저장되어 있는 전체 객체의 수를 리턴합니다.       |
| Collection<V> values()              | 저장된 모든 값을 Collection에 담아서 리턴합니다.     |
| void clear()                        | 저장된 모든 Map.Entry를 삭제합니다.                |
| V remove(Object Key)                | 주어진 키와 일치하는 Map.Entry를 삭제하고 값을 리턴합니다.                                         |

***

추가 내용 

Set과 Map은 중복이 불가능한 데이터가 존재한다. 이 중복의 유무는 클래스 내에서 추가 작업 (put, add)을 명령내렸을 때,
equals, ==, hashCode를 체크하여 중복을 방지한다.

이 메서드들을 오버라이딩하여 수정해주면 다른 방식의 중복을 방지하도록 변경이 가능하다. 

즉, Map의 key와 Set은 요소 추가시 자동으로 equals, hashCode의 비교를 진행한다.



***
<br>
    
    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}