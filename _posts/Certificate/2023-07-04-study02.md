---
title:  "[정보처리기사] 필기공부2" 

categories:
  - Certificate
tags:
  - [Algorithm]

toc: true
toc_sticky: true 

date: 2023-07-04
last_modified_at: 2023-07-04
---

# 정보처리기사

## 2과목 : 소프트웨어 개발

### 전위식 후위식 

``` 
식을 주고 전위식, 후위식으로 변환하라는 문제가 출제되었음 
어떻게 변환하는지 구조를 파악해두자
```

전위 표기법(prefix) - 연산자를 먼저 표시하고 연산에 필요한 피연산자를 나중에 표시하는 방법  
후위 표기법(postfix) - 피연산자를 먼저 표시하고 연산자를 나중에 표시하는 방법  
중위 표기법(infix) - 연산자가 안에, 연산자를 피연산자 사이에 표기 가장 일반적으로 사용되는 표현 방법 

- 1.연산을 진행하는 순서에 맞게 괄호로 묶어줍니다. (또는 연산자에 따라 묶어준다)
- 2.표기법에 해당하는 연산자 위치로 연산자를 괄호를 기준으로 옮겨 줍니다.
- 3.불필요한 괄호들은 제거해줍니다.

> 예시 1 (후위 표기법으로)

``` 
- / * A + B C D E

1. 연산자 순서에 따라 묶어준다. 

- (/ * A + B C D) E

(- (/ * A + B C D) E)

(- (/ (* A + B C) D) E)

(- (/ (* A (+ B C)) D) E)

2. 후위 표기법에 맞게 연산자를 괄호 뒤로 옮긴다.

(- (/ (* A (B C)+) D) E)

(- (/ (A (B C)+)* D) E)

(- ((A (B C)+)* D)/ E)

(((A (B C)+)* D)/ E)-

3. 이동이 완료되었으니 필요없는 괄호 제거 

A B C + * D / E - 


```


> 예시 2 (후위 표기법으로)

``` 
A + B * C - D

1. 연산자 순서에 따라 묶어준다. 

A + ( B * C ) - D

(A + ( B * C )) - D

((A + ( B * C )) - D)

2. 후위 표기법에 맞게 연산자를 괄호 뒤로 옮긴다.

( ( A + ( B * C ) ) - D )
 
( ( A + ( B C ) * ) - D )
 
( ( A ( B C ) * ) + - D )
 
( ( A ( B C ) * ) + D ) -

3. 이동이 완료되었으니 필요없는 괄호 제거 

A B C * + D -

```

### 디자인 패턴 ⭐⭐

``` 
패턴을 나열하고 동일한 패턴 구조가 아닌 문제를 출제
특정 패턴에 대해서도 출제되기도 함
```


생성 패턴, 구조 패턴, 행위 패턴

#### 생성 패턴(Creational Pattern) ⭐

| 패턴명 | 설명 |
|---|---|
| 추상 팩토리(Abstract Factory) | 서로 연관되거나 의존하는 객체들을 그룹으로 생성하며, 이를 추상적으로 표현하는 패턴입니다. |
| 빌더(Builder) | 객체의 생성 과정과 표현 방법을 분리하여 동일한 객체 생성에도 서로 다른 결과를 얻을 수 있는 패턴입니다. |
| 팩토리 메소드(Factory Method) | 객체를 생성하기 위한 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 생성할지를 서브클래스가 결정하도록 하는 패턴입니다. 이를 통해 가상 생성자(Virtual-Constructor) 패턴을 구현할 수 있습니다. |
| 프로토타입(Prototype) | 원본 객체를 복제하는 방법을 제공하는 패턴입니다. 이를 통해 객체를 생성하는 복잡한 과정을 피하고, 새로운 객체를 더 효율적으로 생성할 수 있습니다. |
| 싱글톤(Singleton) | 오직 하나의 인스턴스만을 갖도록 보장하는 패턴으로, 여러 프로세스가 동시에 동일한 객체를 참조할 수 없습니다. |

`추빌팩프싱`

#### 구조 패턴(Structural Pattern) ⭐

| 패턴명 | 설명                                                       |
|---|----------------------------------------------------------|
| 어댑터(Adapter) | 호환성이 없는 클래스, 인터페이스를 변환하여 이용할 수 있도록 해주는 패턴입니다.            |
| 브리지(Bridge) | 구현부와 추상층을 분리하여 독립적으로 확장과 다양성을 가질 수 있게 하는 패턴입니다.          |
| 컴포지트(Composite) | 여러 객체를 가진 복합체를 단일 객체와 구분 없이 다룰 때 사용하는 패턴입니다.             |
| 데코레이터(Decorator) | 상속을 사용하지 않고도 객체의 기능을 동적으로 확장해주는 패턴입니다.                   |
| 퍼싸드(Façade) | 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴입니다. 예를 들면 리모컨처럼 작동합니다. |
| 플라이웨이트(Flyweight) | 공유를 통해 메모리를 절약하는 패턴입니다.                                  |
| 프록시(Proxy) | 접근이 어려운 객체에 대한 인터페이스 역할을 수행하여 접근을 제어하는 패턴입니다.            |

`어브컴데퍼플프`

#### 행위 패턴(Behavioral Pattern)

| 패턴명                            | 설명 |
|--------------------------------|---|
| 책임 연쇄(Chain of Responsibility) | 한 객체가 요청을 처리할 수 없으면 다음 객체로 넘겨 처리하도록 하는 패턴입니다. |
| 커맨드(Command)                   | 요청에 사용되는 각종 명령어를 추상화하고, 구체적인 클래스로 분리하여 단순화하는 패턴입니다. |
| 인터프리터(Interpreter)             | 언어에 문법 표현을 정의하는 패턴으로, 문법의 각 요소를 클래스로 표현하여 해석하고 처리합니다. |
| 반복자(Iterator)                  | 동일한 인터페이스를 사용하여 컬렉션 내부의 요소에 접근하고 순차적으로 반복할 수 있는 패턴입니다. |
| 중재자(Mediator)                  | 객체들이 서로의 존재를 알지 못하더라도 중재자를 통해 협력할 수 있게 하는 패턴입니다. |
| 메멘토(Memento)                   | 객체의 상태를 저장하고 필요한 시점에서 해당 상태로 복원할 수 있는 기능을 제공하는 패턴입니다. |
| 옵저버(Observer)                  | 관찰 대상의 변화를 감지하고, 이를 알림으로써 의존하는 객체들에게 자동으로 변경 사항을 전달하는 패턴입니다. |
| 상태(State)                      | 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴입니다. |
| 전략(Strategy)                   | 클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하여 사용할 수 있게 하는 패턴입니다. |
| 템플릿 메소드(Template Method)       | 유사한 서브클래스들을 묶어 공통된 내용을 상위 클래스에 정의하여 코드의 중복을 최소화하는 패턴입니다. |
| 방문자(Visitor)                   | 필요할 때 해당 클래스에 방문하여 처리를 수행하는 패턴으로, 객체 구조와 작업을 분리시킵니다. |

`생성, 구조 패턴을 외우고 그에 해당하지 않는 패턴이면 행위로 분류`


### CASE(Computer-Aided Software Engineering)의 원천 기술

- 구조적 기법
- 프로토타이핑 기술
- 자동프로그래맹 기술
- 정보 저장소 기술
- 분산 처리 기술






*** 

<br>

    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}