---
title:  "[정보처리기사] 필기공부2" 

categories:
  - Certificate
tags:
  - [Algorithm]

toc: true
toc_sticky: true 

date: 2023-07-04
last_modified_at: 2023-07-04
---

# 정보처리기사

## 2과목 : 소프트웨어 개발

### 전위식 후위식 

``` 
식을 주고 전위식, 후위식으로 변환하라는 문제가 출제되었음 
어떻게 변환하는지 구조를 파악해두자. (괄호만 잘묶어주면 쉬운듯함)
```

전위 표기법(prefix) - 연산자를 먼저 표시하고 연산에 필요한 피연산자를 나중에 표시하는 방법  
후위 표기법(postfix) - 피연산자를 먼저 표시하고 연산자를 나중에 표시하는 방법  
중위 표기법(infix) - 연산자가 안에, 연산자를 피연산자 사이에 표기 가장 일반적으로 사용되는 표현 방법 

- 1.연산을 진행하는 순서에 맞게 괄호로 묶어줍니다. (또는 연산자에 따라 묶어준다)
- 2.표기법에 해당하는 연산자 위치로 연산자를 괄호를 기준으로 옮겨 줍니다.
- 3.불필요한 괄호들은 제거해줍니다.

> 예시 1 (후위 표기법으로)

``` 
- / * A + B C D E

1. 연산자 순서에 따라 묶어준다. 

- (/ * A + B C D) E

(- (/ * A + B C D) E)

(- (/ (* A + B C) D) E)

(- (/ (* A (+ B C)) D) E)

2. 후위 표기법에 맞게 연산자를 괄호 뒤로 옮긴다.

(- (/ (* A (B C)+) D) E)

(- (/ (A (B C)+)* D) E)

(- ((A (B C)+)* D)/ E)

(((A (B C)+)* D)/ E)-

3. 이동이 완료되었으니 필요없는 괄호 제거 

A B C + * D / E - 


```


> 예시 2 (후위 표기법으로)

``` 
A + B * C - D

1. 연산자 순서에 따라 묶어준다. 

A + ( B * C ) - D

(A + ( B * C )) - D

((A + ( B * C )) - D)

2. 후위 표기법에 맞게 연산자를 괄호 뒤로 옮긴다.

( ( A + ( B * C ) ) - D )
 
( ( A + ( B C ) * ) - D )
 
( ( A ( B C ) * ) + - D )
 
( ( A ( B C ) * ) + D ) -

3. 이동이 완료되었으니 필요없는 괄호 제거 

A B C * + D -

```

***

### 디자인 패턴 ⭐⭐

``` 
패턴을 나열하고 동일한 패턴 구조가 아닌 문제를 출제
특정 패턴에 대해서도 출제되기도 함
```


생성 패턴, 구조 패턴, 행위 패턴

#### 생성 패턴(Creational Pattern) ⭐

| 패턴명 | 설명 |
|---|---|
| 추상 팩토리(Abstract Factory) | 서로 연관되거나 의존하는 객체들을 그룹으로 생성하며, 이를 추상적으로 표현하는 패턴입니다. |
| 빌더(Builder) | 객체의 생성 과정과 표현 방법을 분리하여 동일한 객체 생성에도 서로 다른 결과를 얻을 수 있는 패턴입니다. |
| 팩토리 메소드(Factory Method) | 객체를 생성하기 위한 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 생성할지를 서브클래스가 결정하도록 하는 패턴입니다. 이를 통해 가상 생성자(Virtual-Constructor) 패턴을 구현할 수 있습니다. |
| 프로토타입(Prototype) | 원본 객체를 복제하는 방법을 제공하는 패턴입니다. 이를 통해 객체를 생성하는 복잡한 과정을 피하고, 새로운 객체를 더 효율적으로 생성할 수 있습니다. |
| 싱글톤(Singleton) | 오직 하나의 인스턴스만을 갖도록 보장하는 패턴으로, 여러 프로세스가 동시에 동일한 객체를 참조할 수 없습니다. |

`추빌팩프싱`

#### 구조 패턴(Structural Pattern) ⭐

| 패턴명 | 설명                                                       |
|---|----------------------------------------------------------|
| 어댑터(Adapter) | 호환성이 없는 클래스, 인터페이스를 변환하여 이용할 수 있도록 해주는 패턴입니다.            |
| 브리지(Bridge) | 구현부와 추상층을 분리하여 독립적으로 확장과 다양성을 가질 수 있게 하는 패턴입니다.          |
| 컴포지트(Composite) | 여러 객체를 가진 복합체를 단일 객체와 구분 없이 다룰 때 사용하는 패턴입니다.             |
| 데코레이터(Decorator) | 상속을 사용하지 않고도 객체의 기능을 동적으로 확장해주는 패턴입니다.                   |
| 퍼싸드(Façade) | 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴입니다. 예를 들면 리모컨처럼 작동합니다. |
| 플라이웨이트(Flyweight) | 공유를 통해 메모리를 절약하는 패턴입니다.                                  |
| 프록시(Proxy) | 접근이 어려운 객체에 대한 인터페이스 역할을 수행하여 접근을 제어하는 패턴입니다.            |

`어브컴데퍼플프`

#### 행위 패턴(Behavioral Pattern)

| 패턴명                            | 설명 |
|--------------------------------|---|
| 책임 연쇄(Chain of Responsibility) | 한 객체가 요청을 처리할 수 없으면 다음 객체로 넘겨 처리하도록 하는 패턴입니다. |
| 커맨드(Command)                   | 요청에 사용되는 각종 명령어를 추상화하고, 구체적인 클래스로 분리하여 단순화하는 패턴입니다. |
| 인터프리터(Interpreter)             | 언어에 문법 표현을 정의하는 패턴으로, 문법의 각 요소를 클래스로 표현하여 해석하고 처리합니다. |
| 반복자(Iterator)                  | 동일한 인터페이스를 사용하여 컬렉션 내부의 요소에 접근하고 순차적으로 반복할 수 있는 패턴입니다. |
| 중재자(Mediator)                  | 객체들이 서로의 존재를 알지 못하더라도 중재자를 통해 협력할 수 있게 하는 패턴입니다. |
| 메멘토(Memento)                   | 객체의 상태를 저장하고 필요한 시점에서 해당 상태로 복원할 수 있는 기능을 제공하는 패턴입니다. |
| 옵저버(Observer)                  | 관찰 대상의 변화를 감지하고, 이를 알림으로써 의존하는 객체들에게 자동으로 변경 사항을 전달하는 패턴입니다. |
| 상태(State)                      | 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴입니다. |
| 전략(Strategy)                   | 클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하여 사용할 수 있게 하는 패턴입니다. |
| 템플릿 메소드(Template Method)       | 유사한 서브클래스들을 묶어 공통된 내용을 상위 클래스에 정의하여 코드의 중복을 최소화하는 패턴입니다. |
| 방문자(Visitor)                   | 필요할 때 해당 클래스에 방문하여 처리를 수행하는 패턴으로, 객체 구조와 작업을 분리시킵니다. |

`생성, 구조 패턴을 외우고 그에 해당하지 않는 패턴이면 행위로 분류`


### CASE(Computer-Aided Software Engineering)의 원천 기술 ⭐

``` 
보기에 원천기술이 아닌 정보와 함께 출제하여 아닌 것을 찾는 문제 등..
```

- 구조적 기법
- 프로토타이핑 기술
- 자동프로그래맹 기술
- 정보 저장소 기술
- 분산 처리 기술

### 블랙박스, 화이트박스 테스트

> 화이트박스 테스트

화이트 박스 테스트는 소프트웨어의 내부 동작과 구조를 이해하고 분석하여 테스트 케이스를 설계하는 방법입니다.

테스트를 수행하는 사람은 소프트웨어의 코드와 내부 구현을 알고있으며, 이를 기반으로 테스트 케이스를 작성하고 실행합니다.

소프트웨어의 모든 분기점과 경로를 테스트할 수 있으며, 코드의 특정부분에 집중하여 테스트도 진행 가능하다.

이를 통해서 소프트웨어의 정확성, 실행 흐름, 논리적 오류 등을 확인 가능하다.

> 블랙박스 테스트

소프트웨어의 내부 동작과 구조를 몰라도 테스트를 수행할 수 있는 방법이다. 

테스트를 수행하는 사람은 소프트웨어의 입력, 출력, 기능, 요구사항에 초점을 두고 테스트 케이스를 설계하고 실행한다.

기능적인 측면을 중심으로 테스트하며, 사용자의 관점에서 소프트웨어가 예상대로 동작하는지 확인한다.

소프트웨어의 외부 동작을 효과적으로 검증 가능하다.

`화이트 박스 테스트는 내부 구현을 직접 확인하여 코드 품질과 성능을 평가하고 개선할 수 있지만, 
시간과 리소스가 많이 소요될 수 있습니다. 반면에 블랙 박스 테스트는 사용자의 요구사항과 기능을 
중심으로 테스트하며, 기능 검증과 사용자 관점에서의 검증에 유리합니다.`

### Sorting 알고리즘 

#### 선택 정렬

순서에 따라 index 값에서 부터 나머지 데이터를 하나의 리스트화 하여 리스트 중에 최소값을 찾아 그 값을 교체한다.

순서대로 앞에서 부터 가장 작은 값을 위치 시킨다. 

> [5, 2, 8, 3, 1]

``` 
1. 1번 위치에 있는 5를 가장 작은 값을 찾아 위치를 바꿔준다.

[1, 2, 8, 3, 5] 
-> 5와 1 위치 변경

2. 2번 위치에 있는 2를 가장 작은 값을 찾아 위치를 바꿔준다. 

[1, 2, 8, 3, 5] 
-> 최소값은 2이므로 변경되는 값은 없다. (2, 8, 3, 5)

3. 3번 위치에 있는 8을 가장 작은 값을 찾아 위치를 바꿔준다. 

[1, 2, 3, 8, 5] 
-> 8과 3 위치 변경 (8, 3, 5)

4. 4번 위치에 있는 8을 가장 작은 값을 찾아 위치를 바꿔준다. 

[1, 2, 3, 5, 8] 
-> 8과 5 위치 변경 (8, 5)
```

#### 버블 정렬

> [5, 2, 8, 3, 1]














*** 

<br>

    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}