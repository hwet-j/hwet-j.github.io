---
title:  "[정보처리기사] 필기공부2" 

categories:
  - Certificate
tags:
  - [Algorithm]

toc: true
toc_sticky: true 

date: 2023-07-04
last_modified_at: 2023-07-04
---

[참고](https://velog.io/@kerri/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Sorting-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A0%ED%83%9D-%EB%B2%84%EB%B8%94-%EC%82%BD%EC%9E%85-%ED%95%A9%EB%B3%91-%ED%80%B5-%EC%86%8C%ED%8A%B8-%ED%9E%99-%EC%86%8C%ED%8A%B8-%EB%B9%84%EA%B5%90)


# 정보처리기사

## 여러가지

### 전위식 후위식 

``` 
식을 주고 전위식, 후위식으로 변환하라는 문제가 출제되었음 
어떻게 변환하는지 구조를 파악해두자. (괄호만 잘묶어주면 쉬운듯함)
```

전위 표기법(prefix) - 연산자를 먼저 표시하고 연산에 필요한 피연산자를 나중에 표시하는 방법  
후위 표기법(postfix) - 피연산자를 먼저 표시하고 연산자를 나중에 표시하는 방법  
중위 표기법(infix) - 연산자가 안에, 연산자를 피연산자 사이에 표기 가장 일반적으로 사용되는 표현 방법 

- 1.연산을 진행하는 순서에 맞게 괄호로 묶어줍니다. (또는 연산자에 따라 묶어준다)
- 2.표기법에 해당하는 연산자 위치로 연산자를 괄호를 기준으로 옮겨 줍니다.
- 3.불필요한 괄호들은 제거해줍니다.

> 예시 1 (후위 표기법으로)

``` 
- / * A + B C D E

1. 연산자 순서에 따라 묶어준다. 

- (/ * A + B C D) E

(- (/ * A + B C D) E)

(- (/ (* A + B C) D) E)

(- (/ (* A (+ B C)) D) E)

2. 후위 표기법에 맞게 연산자를 괄호 뒤로 옮긴다.

(- (/ (* A (B C)+) D) E)

(- (/ (A (B C)+)* D) E)

(- ((A (B C)+)* D)/ E)

(((A (B C)+)* D)/ E)-

3. 이동이 완료되었으니 필요없는 괄호 제거 

A B C + * D / E - 


```


> 예시 2 (후위 표기법으로)

``` 
A + B * C - D

1. 연산자 순서에 따라 묶어준다. 

A + ( B * C ) - D

(A + ( B * C )) - D

((A + ( B * C )) - D)

2. 후위 표기법에 맞게 연산자를 괄호 뒤로 옮긴다.

( ( A + ( B * C ) ) - D )
 
( ( A + ( B C ) * ) - D )
 
( ( A ( B C ) * ) + - D )
 
( ( A ( B C ) * ) + D ) -

3. 이동이 완료되었으니 필요없는 괄호 제거 

A B C * + D -

```

***

### 디자인 패턴 ⭐⭐

``` 
패턴을 나열하고 동일한 패턴 구조가 아닌 문제를 출제
특정 패턴에 대해서도 출제되기도 함
```


생성 패턴, 구조 패턴, 행위 패턴

#### 생성 패턴(Creational Pattern) ⭐

| 패턴명 | 설명 |
|---|---|
| 추상 팩토리(Abstract Factory) | 서로 연관되거나 의존하는 객체들을 그룹으로 생성하며, 이를 추상적으로 표현하는 패턴입니다. |
| 빌더(Builder) | 객체의 생성 과정과 표현 방법을 분리하여 동일한 객체 생성에도 서로 다른 결과를 얻을 수 있는 패턴입니다. |
| 팩토리 메소드(Factory Method) | 객체를 생성하기 위한 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 생성할지를 서브클래스가 결정하도록 하는 패턴입니다. 이를 통해 가상 생성자(Virtual-Constructor) 패턴을 구현할 수 있습니다. |
| 프로토타입(Prototype) | 원본 객체를 복제하는 방법을 제공하는 패턴입니다. 이를 통해 객체를 생성하는 복잡한 과정을 피하고, 새로운 객체를 더 효율적으로 생성할 수 있습니다. |
| 싱글톤(Singleton) | 오직 하나의 인스턴스만을 갖도록 보장하는 패턴으로, 여러 프로세스가 동시에 동일한 객체를 참조할 수 없습니다. |

`추빌팩프싱`

#### 구조 패턴(Structural Pattern) ⭐

| 패턴명 | 설명                                                       |
|---|----------------------------------------------------------|
| 어댑터(Adapter) | 호환성이 없는 클래스, 인터페이스를 변환하여 이용할 수 있도록 해주는 패턴입니다.            |
| 브리지(Bridge) | 구현부와 추상층을 분리하여 독립적으로 확장과 다양성을 가질 수 있게 하는 패턴입니다.          |
| 컴포지트(Composite) | 여러 객체를 가진 복합체를 단일 객체와 구분 없이 다룰 때 사용하는 패턴입니다.             |
| 데코레이터(Decorator) | 상속을 사용하지 않고도 객체의 기능을 동적으로 확장해주는 패턴입니다.                   |
| 퍼싸드(Façade) | 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴입니다. 예를 들면 리모컨처럼 작동합니다. |
| 플라이웨이트(Flyweight) | 공유를 통해 메모리를 절약하는 패턴입니다.                                  |
| 프록시(Proxy) | 접근이 어려운 객체에 대한 인터페이스 역할을 수행하여 접근을 제어하는 패턴입니다.            |

`어브컴데퍼플프`

#### 행위 패턴(Behavioral Pattern)

| 패턴명                            | 설명 |
|--------------------------------|---|
| 책임 연쇄(Chain of Responsibility) | 한 객체가 요청을 처리할 수 없으면 다음 객체로 넘겨 처리하도록 하는 패턴입니다. |
| 커맨드(Command)                   | 요청에 사용되는 각종 명령어를 추상화하고, 구체적인 클래스로 분리하여 단순화하는 패턴입니다. |
| 인터프리터(Interpreter)             | 언어에 문법 표현을 정의하는 패턴으로, 문법의 각 요소를 클래스로 표현하여 해석하고 처리합니다. |
| 반복자(Iterator)                  | 동일한 인터페이스를 사용하여 컬렉션 내부의 요소에 접근하고 순차적으로 반복할 수 있는 패턴입니다. |
| 중재자(Mediator)                  | 객체들이 서로의 존재를 알지 못하더라도 중재자를 통해 협력할 수 있게 하는 패턴입니다. |
| 메멘토(Memento)                   | 객체의 상태를 저장하고 필요한 시점에서 해당 상태로 복원할 수 있는 기능을 제공하는 패턴입니다. |
| 옵저버(Observer)                  | 관찰 대상의 변화를 감지하고, 이를 알림으로써 의존하는 객체들에게 자동으로 변경 사항을 전달하는 패턴입니다. |
| 상태(State)                      | 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴입니다. |
| 전략(Strategy)                   | 클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하여 사용할 수 있게 하는 패턴입니다. |
| 템플릿 메소드(Template Method)       | 유사한 서브클래스들을 묶어 공통된 내용을 상위 클래스에 정의하여 코드의 중복을 최소화하는 패턴입니다. |
| 방문자(Visitor)                   | 필요할 때 해당 클래스에 방문하여 처리를 수행하는 패턴으로, 객체 구조와 작업을 분리시킵니다. |

`생성, 구조 패턴을 외우고 그에 해당하지 않는 패턴이면 행위로 분류`


### CASE(Computer-Aided Software Engineering)의 원천 기술 ⭐

``` 
보기에 원천기술이 아닌 정보와 함께 출제하여 아닌 것을 찾는 문제 등..
```

- 구조적 기법
- 프로토타이핑 기술
- 자동프로그래맹 기술
- 정보 저장소 기술
- 분산 처리 기술

### 블랙박스, 화이트박스 테스트

> 화이트박스 테스트

화이트 박스 테스트는 소프트웨어의 내부 동작과 구조를 이해하고 분석하여 테스트 케이스를 설계하는 방법입니다.

테스트를 수행하는 사람은 소프트웨어의 코드와 내부 구현을 알고있으며, 이를 기반으로 테스트 케이스를 작성하고 실행합니다.

소프트웨어의 모든 분기점과 경로를 테스트할 수 있으며, 코드의 특정부분에 집중하여 테스트도 진행 가능하다.

이를 통해서 소프트웨어의 정확성, 실행 흐름, 논리적 오류 등을 확인 가능하다.

> 블랙박스 테스트

소프트웨어의 내부 동작과 구조를 몰라도 테스트를 수행할 수 있는 방법이다. 

테스트를 수행하는 사람은 소프트웨어의 입력, 출력, 기능, 요구사항에 초점을 두고 테스트 케이스를 설계하고 실행한다.

기능적인 측면을 중심으로 테스트하며, 사용자의 관점에서 소프트웨어가 예상대로 동작하는지 확인한다.

소프트웨어의 외부 동작을 효과적으로 검증 가능하다.

`화이트 박스 테스트는 내부 구현을 직접 확인하여 코드 품질과 성능을 평가하고 개선할 수 있지만, 
시간과 리소스가 많이 소요될 수 있습니다. 반면에 블랙 박스 테스트는 사용자의 요구사항과 기능을 
중심으로 테스트하며, 기능 검증과 사용자 관점에서의 검증에 유리합니다.`

### Sorting 알고리즘 

#### 선택 정렬 (Selection Sort)

순서대로 앞에서 부터 차례대로 정렬하는 방법이다. 주어진 리스트 중에서 최소값을 찾아내 그 값을 순차적으로 값을 교체하는 방식으로 정렬한다. 

구현이 간단하고 추가적인 메모리 공간이 필요하지 않지만, 길이에 따라 비교 및 교환 횟수가 많아져 성능이 저하되고 소수의 자료가 추가되었을 때 정렬할 때에도 비효율적이다.

> [5, 2, 8, 3, 1]

``` 
1. 첫번째 정렬 - 1번 위치에 있는 5를 가장 작은 값을 찾아 위치를 바꿔준다.

[1, 2, 8, 3, 5] 
-> 5와 1 위치 변경

2. 두번째 정렬 - 2번 위치에 있는 2를 가장 작은 값을 찾아 위치를 바꿔준다. 

[1, 2, 8, 3, 5] 
-> 최소값은 2이므로 변경되는 값은 없다. (2, 8, 3, 5)

3. 세번째 정렬 - 3번 위치에 있는 8을 가장 작은 값을 찾아 위치를 바꿔준다. 

[1, 2, 3, 8, 5] 
-> 8과 3 위치 변경 (8, 3, 5)

4. 네번째 정렬 - 4번 위치에 있는 8을 가장 작은 값을 찾아 위치를 바꿔준다. 

[1, 2, 3, 5, 8] 
-> 8과 5 위치 변경 (8, 5)
```

#### 버블 정렬 (Bubble Sort)

앞에서 부터 인접한 원소끼리 비교하여 큰 숫자를 뒤쪽으로 교환하면서 맨 끝부터 정렬하는 방식이다.

데이터를 하나씩 비교할 수 있어 정밀도 높게 비교 가능하지만, 선택 정렬과 비슷하게 길이가 길어지면 비교 및 교환 횟수가 많아져 비효율적이다. 

> [5, 2, 8, 3, 1]

``` 
1. 첫번째 정렬 - 인접한 숫자를 비교하며 가장 마지막 위치를 정렬을 완료한다.

[5, 2, 8, 3, 1] - 정렬 시작 전
[2, 5, 8, 3, 1] - 5, 2 비교 (5가 더 크므로 위치 변환)
[2, 5, 8, 3, 1] - 5, 8 비교 (5가 더 작으므로 위치 변환X)
[2, 5, 3, 8, 1] - 8, 3 비교 (8이 더 크므로 위치 변환)
[2, 5, 3, 1, 8] - 8, 1 비교 (8이 더 크므로 위치 변환)

2. 두번째 정렬

[2, 5, 3, 1, 8] - 정렬 시작 전
[2, 5, 3, 1, 8] - 2, 5 비교 (2가 더 작으므로 위치 변환X)
[2, 3, 5, 1, 8] - 5, 3 비교 (5가 더 크므로 위치 변환)
[2, 3, 1, 5, 8] - 5, 1 비교 (5가 더 크므로 위치 변환)
--> 마지막 인덱스는 이미 정렬 완료 상태

3. 세번째 정렬

[2, 3, 1, 5, 8] - 정렬 시작 전
[2, 3, 1, 5, 8] - 2, 3 비교 (2가 더 작으므로 위치 변환X)
[2, 1, 3, 5, 8] - 3, 1 비교 (3가 더 크므로 위치 변환)
--> 이후 인덱스는 이미 정렬 완료 상태

4. 네번째 정렬

[2, 1, 3, 5, 8] - 정렬 시작 전
[1, 2, 3, 5, 8] - 2, 1 비교 (2가 더 크므로 위치 변환)
--> 이후 인덱스는 이미 정렬 완료 상태
```

#### 삽입 정렬 (Insertion Sort)

요소를 앞에서부터 차례대로 이미 정렬된 리스트들과 비교하여 특정 값보다 크면 그 값뒤에 삽입하며 정렬하는 방법이다.

새로운 데이터를 삽입했을 경우에도 효율적이며, 버블정렬의 비교횟수를 줄이고 보다 좋은 효율을 보여준다.

> [6, 5, 3, 1, 8, 7, 2, 4]

``` 
1. 첫번째 정렬

[5, 6, 3, 1, 8, 7, 2, 4] - 5는 6보다 작고 더이상 비교대상이 없으므로 5를 가장 앞으로 이동한다.

2. 두번째 정렬

[3, 5, 6, 1, 8, 7, 2, 4] - 3은 5, 6 보다 작고 더이상 비교대상이 없으므로 3을 가장 앞으로 이동한다.

3. 세번째 정렬

[1, 3, 5, 6, 8, 7, 2, 4] - 1은 3, 5, 6 보다 작고 더이상 비교대상이 없으므로 1을 가장 앞으로 이동한다.

4. 네번째 정렬

[1, 3, 5, 6, 8, 7, 2, 4] - 8은 어떤 비교대상 중 어떤값보다도 작지 않으므로 이동하지 않는다.

5. 다섯번째 정렬

[1, 3, 5, 6, 7, 8, 2, 4] - 7은 8보다 작고 6보다 크므로 그 사이로 이동한다.

6. 여섯번째 정렬

[1, 2, 3, 5, 6, 7, 8, 4] - 2는 1보다 크고 3보다 작으므로 그 사이로 이동한다.

7. 일곱번째 정렬

[1, 2, 3, 4, 5, 6, 7, 8] - 4는 3보다 크고 5보다 작으므로 그 사이로 이동한다.
```

#### 합병 정렬 (Merge Sort)

주어진 리스트를 잘게 쪼개어 작은 단위부터 정렬하여 정렬된 단위를 계속해서 정렬하는 방식

안정성이 있게 좋은 성능을 보여주지만, 공간이 많이 필요하다는 단점이 있다.

> [6, 5, 3, 7, 2, 4, 1, 8]

``` 
1.단위별 잘게 쪼갠다

[6, 5, 3, 7] , [2, 4, 1, 8]
[ [6, 5] , [3, 7] ], [ [2, 4], [1, 8] ]
[[ [6], [5] ], [ [3], [7] ]], [[ [2], [4] ], [ [1], [8] ]]

2. 단위별로 정렬해 나간다.

2-1. 가장 작은 단위의 데이터 끼리 비교하여 위치조정
[[ [5], [6] ], [ [3], [7] ]], [[ [2], [4] ], [ [1], [8] ]]

2-2. 다음 단위끼리 데이터를 비교
[[ [5], [6] ], [ [3], [7] ]]

# 5와 3과 비교 (3이 작음) - 작은 값을 하나씩 앞에 배치
[3]
# 5와 7과 비교 (5가 작음)
[3] [5]
# 6과 7을 비교 (6이 작음) - 현재 단위에서 비교대상이 없어 7을 마지막에 배치
[3] [5] [6] [7]

2-3. 2-2와 동일 단위 데이터를 비교
[[ [2], [4] ], [ [1], [8] ]]

# 2와 1을 비교
[1]
# 2와 8을 비교
[1] [2] 
# 4와 8을 비교
[1] [2] [4] [8]

2-4. 다음 단위 데이터를 비교 
[ [3] [5] [6] [7] ], [ [1] [2] [4] [8] ]

# 3과 1을 비교 
[1] 
# 3과 2를 비교 
[1] [2] 
# 3과 4를 비교
[1] [2] [3]
# 5와 4를 비교 
[1] [2] [3] [4]
# 5와 8을 비교
[1] [2] [3] [4] [5]
# 6과 8을 비교
[1] [2] [3] [4] [5] [6]
# 7과 8을 비교 -> 더이상 비교대상이 없으므로 8도 배치
[1] [2] [3] [4] [5] [6] [7] [8]
```

#### 퀵 정렬 (Quick Sort)

연속적인 분할에 의한 정렬 방식이다. 처음 하나의 축(Pivot)을 정하여 이 축의 값보다 작은 값은
왼쪽에 큰 값은 오른쪽에 위치시킨뒤 왼쪽과 오른쪽의 수 들은 다시 각각의 축으로 나누어져 축값이 1이될 때까지 정렬한다.

pivot은 임의의 위치로 설정해도 상관은없지만 일반적으로 가장 앞 원소, 중간 원소, 마지막 원소를 선택하는 방법으로 한다.

> [5, 3, 8, 4, 9, 1, 6, 2, 7]

``` 
1. 첫 위치를 기준(pivot)으로 정렬 

# pivot으로 나뉜 리스트를 가장 왼쪽(left), 가장 오른쪽(right)에서 부터 정렬을 시작한다.
[5] 를 제외하고 left는 3, right는 7

# left는 pivot보다 큰 수이거나 pivot을 만나면 멈춘고, right는 pivot보다 작은 수이거나 pivot을 만나면 멈춘다.
left : 8, right : 2 에서 멈춘다.  

# 멈춘 위치에서 left, right를 교환한다. (left가 right보다 왼쪽에 있다면 값을 교환)
[5, 3, 2, 4, 9, 1, 6, 8, 7]

# 멈춘 위치의 다음 위치에서부터 반복작업을 한다.
left : 9, right : 1 에서 멈춘다.

# 멈춘 위치에서 left, right를 교환한다.
[5, 3, 2, 4, 1, 9, 6, 8, 7]

# 더 이상 작업할 수 없으면 pivot과 마지막 left위치와 비교하여 pivot이 더크면 교환한다.
[1, 3, 2, 4, 5, 9, 6, 8, 7]


2. 첫 피벗을 기준으로 left, right에서 새로운 피벗을 설정하여 동일 작업을 진행한다.
left : [1, 3, 2, 4], right : [9, 6, 8, 7]

2-1. 좌측 데이터 진행 - pivot을 첫 번째 요소 1로 설정
left : 3, right : 1 

# left가 right보다 우측에 있으므로 이동없이 종료한다.
[1, 3, 2, 4]

# [1]을 제외한 [3, 2, 4] 에서 정렬을 진행한다. (pivot 2)
left : 3, right : 2 

# left와 right를 교환한다.
[2, 3, 4]

# 최종적으로 첫 pivot기준 좌측 데이터는
[1, 2, 3, 4]

2-2. 우측 데이터 진행 - pivot을 첫 번째 요소 9로 설정
left : 7, right : 7 

# left의 위치가 right가 동일하여 이동이 없지만, pivot과 마지막 left위치와 비교하여 pivot이 더크면 교환한다.
[7, 6, 8, 9]

# 이동이 완료된 [9]를 제외하고 [7, 6, 8]을 정렬 - pivot 6으로 설정
left : 7, right : 6 

# left와 right를 교환한다.
[6, 7, 8]

3. 최종적으로 정렬된 데이터 
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

#### 힙 정렬 (Heap Sort)

- 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조  
- 최대값, 최소값을 쉽게 추출할 수 있는 자료구조
- 최대 힙, 최소 힙 트리를 구성해 정렬하는 방법이있다. 

최대 힙은 노드의 가장 첫번째 부분에 최대 값이 오도록 하면서 구성해 나가는 방식이다. (최소 힙은 반대)

![위키백과](https://github.com/hwet-j/hwet-j.github.io/assets/81364742/0cbacefc-0913-4a26-adef-16ae84a84bb8)  

[출처 : 위키백과](https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC)

> [6, 5, 3, 1, 8, 7, 2, 4]

``` 
첨부된 이미지를 보면서 이해하시기 바랍니다.

(최대 힙 트리)
1. 6을 최상단에 배치 

2. 5를 6의 왼쪽 자식 노드에 배치

3. 3을 6의 오른쪽 자식 노드에 배치
 
4. 1을 5의 왼쪽 자식 노드에 배치   

5. 8을 5의 오른쪽 자식 노드에 배치 
5-1. 8이 5보다 크므로 8과 5의 위치를 교환
5-2. 8이 6보다 크므로 8과 6의 위치를 교환
 
6. 7을 3의 왼쪽 자식 노드에 배치
6-1 7이 3보다 크므로 7과 3의 위치를 교환

7. 2를 3의 오른쪽 자식 노드에 배치

8. 4를 1의 자식 노드에 배치
8-1. 4가 1보다 크므로 4와 1의 위치를 교환

9. 더 이상 남은 요소가 없으므로 최상단 요소 추출하고 정렬 최하단 요소로 대체
정렬 데이터 : [8]

10. 추출된 위치의 자식노드 값을 비교하여 더 큰값을 이동 (더이상 이동이 없을 때까지)

11. 9,10을 반복
[1, 2, 3, 4, 5, 6, 7, 8] 로 정렬된다.
```
 




*** 

<br>

    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}