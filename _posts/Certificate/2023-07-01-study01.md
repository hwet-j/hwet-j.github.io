---
title:  "[정보처리기사] 필기공부2" 

categories:
  - Certificate
tags:
  - [Algorithm]

toc: true
toc_sticky: true 

date: 2023-07-01
last_modified_at: 2023-07-01
---

# 정보처리기사

## 1과목 : 소프트웨어 설계

### 결합도 ⭐⭐⭐⭐

```
결합도는 결합도들의 개별적인 의미나 결합의 정도 등을 구분하는 문제가 자주 출제됨
```

- 결합도는 두 모듈간의 상호작용 또는 의존도 정도를 나타내는 것이다.
- 모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.
- 결합도가 강할수록 품질이 낮으며, 시스템 구현 및 유지보수 작업이 어렵다.
- 결합도는 낮을수록 좋다. (=독립적인 모듈)

> 자료 결합도 (Data Coupling)

어떤 모듈이 다른 모듈을 호출하면서 매개변수나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 결합도

> 스탬프 결합도 (Stamp Coupling)

두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다. 

> 제어 겹합도 (Control Coupling)

어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어신호를 이용하여 통신하는 경우이며, 
하위 모듈에서 상위 모듈로 제어신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도현상이 발생하게 되는 결합도

> 외부 결합도 (External Coupling)

어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도

> 공통 결합도 (Common Coupling)

두 모듈이 동일한 전역 데이터를 접근한다면 공통결합 되어있다. (전역 변수)

> 내용 결합도 (Content Coupling)

하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있다고 한다.

**자스제외공내(결합도 약->강)**

***

### 익스트림 프로그래밍 (eXtreme Programming) ⭐⭐⭐

``` 
XP의 5가지 핵심 가치와 XP특징에 관련하여 출제됨
```

> XP의 핵심 가치

- 용기 (Courage)
- 단순성 (Simplicity)
- 의사소통 (Communication)
- 피드백 (Feedback)
- 존중 (Respect)

> XP의 특징 

- 수시로 변화할 수 있는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상
- 고객과 직접 대면(고객이 기능 작동에 대해 직접확인)하여 요구사항을 이야기하기 위해 사용자 스토리(User Story)를 활용할 수 있다. 
- 비교적 소규모 인원의 개발 프로젝트에 효과적이다.

***

### HIPO (Hierarchy Input Process Output)

``` 
HIPO의 특징 및 HIPO의 종류 3가지인 가시적 도표, 총체적 도표, 세부적 도표를 구분할 수 있도록 특징을 정리
```

- 하향식 소프트웨어 개발을 위한 문서화 도구이다.
- HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.
- 기능과 자료의 의존 관계를 동시에 표현할 수 있다.
- (기호, 도표 등을 사용하므로) 보기가 쉽고 이해하기 쉽다.
- 변경, 유지보수가 용이하다.

> 가시적 도표 (Visual Table of Contents)

시스템 전체 기능과 흐름을 보여주는 Tree(계층) 구조

> 총체적 도표 (Overview Diagram)

프로그램을 구성하는 기능을 기술한 것. 입력, 처리, 출력에 대한 전반적인 정보 제공

> 세부적 도표 (Detail Diagram)

총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

***

### UI (User Interface) ⭐

``` 
크게 어렵지 않으므로 가볍게 읽어볼 것 
```

- CLI (Command Line Interface) : 키보드를 통한 텍스트 입력과 출력 / 대표적으로 DOS 및 Unix 등의 운영체제에서 조작을 위해 사용하던 것으로, 정해진 명령문자열을 입력하여 시스템을 조작하는 사용자 인터페이스
- GUI (Graphical User Interface) : 마우스를 통한 그래픽 / 마우스로 선택해 작업을 하는 그래픽 환경의 인터페이스
- NUI (Natural User Interface) : 사람의 신체를 통한 입력과 출력 제어 / 사용자의 말이나 행동으로 기기를 조작하는 인터페이스 
- VUI (Voice User Interface) : 사람의 음성으로 기기를 조작하는 인터페이스
- OUI (Organic User Interface) : 자연 그대로의 상태 특성들을 반영한 장치 제어 / 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

> UI의 기본 원칙

- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야한다. 
- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 한다. 
- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다.
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야한다.

***

### UML (Unified Modeling Language)

``` 
UML에 대해서는 작성한 내용이외에도 봐야할 것이 많음
```

> UML 구성요소

| 분류               | 항목                             |
|-------------------|----------------------------------|
| 사물(Things)      | 구조, 행위, 그룹, 주석 등       |
| 관계(Relationships) | 의존 관계, 연관 관계, 일반화 관계 등 |
| 다이어그램(Diagrams) | 객체 다이어그램, 클래스 다이어그램, 시퀀스 다이어그램 등 |

> UML 다어어그램에서 관계 표현 ⭐⭐

| 명칭        | 표현               | 설명                                                                            |
|-------------|-------------------|-------------------------------------------------------------------------------|
| 연관 관계 | ────>             | 객체간 개념적으로 연관 (2개 이상의 사물이 서로 관련되어 있음)                                          |
| 의존 관계 | - - - - - ->     | 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계          |
| 집합 관계 | ────◇           | 전체와 부분인 연관 관계 (하나의 사물이 다른 사물에 포함되어 있는 관계)                                     |
| 포함 관계 | ────◆           | 전체 소멸 시 부분도 소멸되는 집합 연관 관계 (집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계) |
| 일반화 관계 | ────▷         | 일반화된 개념과 구체화된 객체의 관계 (하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현하는 관계)               |
| 실체화 관계 | - - - - - -▷ | 인터페이스와 그것을 실체로 구현한 객체의 관계 (사물이 할 수 있거나 해야하는 기능(행위,인터페이스)으로 서로 그룹화 할 수 있는 관계 ) |


### 자료흐름도 (DFD : Data Flow Diagram) ⭐⭐

``` 
자료흐름도의 구성요소 및 표시기호 등을 잘 파악 (영문으로도 자주 출제)
```


> 자료흐름도의 구성요소

| 구성요소                 | 표현                               | 설명                                                       |
|----------------------|----------------------------------|----------------------------------------------------------|
| 프로세스  (Process)      | 원이나 둥근 사각형으로 표기하고 그 안에 프로세스 이름을 기입 | 자료를 변환시키는 시스템의 한 부분(처리 과정)을 나타내며 처리,기능,변환,버블이라고도 함       |
| 자료 흐름  (Data Flow)   | 화살표 위에 자료의 이름을 기입                | 자료의 이동(흐름)이나 연관관계를 나타냄                                   |
| 자료 저장소  (Data Store) | 평행선 안에 자료 저장소 이름을 기입             | 시스템에서의 자료 저장소(파일,데이터베이스)를 나타냄                            |
| 단말  (Terminator)     | 사각형 안에 이름을 기입                    | 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음(정보의 생산자와 소비자) |

***

### 객체지향 설계 원칙 (SOLID) ⭐⭐

``` 
객체지향 설계 원칙의 종류와 각각의 특징을 정리
```

> SRP (단일 책임 원칙, Single Responsibility Principle)

- 객체는 단 하나의 책임만 가져야 한다. 
- 응집도는 높고, 결합도는 낮게 설계하는 것을 의미한다.

> OCP (개방-폐쇄 원칙, Open-Closed Principle)

- 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
- 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적 (확장에 대해 열려있고, 수정에대해 닫혀있어야 한다.)

> LSP (리스코프 치환 원칙, Liskov Substitution Principle)

- 의존 관계를 맺을 때, 변화하기 쉬운 것보다 변화하기 어려운 것에 의존해야 한다.
- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙이다.
- 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야한다.

> ISP (인터페이스 분리 원칙, Interface Segregation Principle)

- 클라이언트는 자신이 사용하지 않는 메서드 및 인터페이스와 의존관계 맺거나 영향을 받아서는 안된다.
- 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙은 인터페이스가 갖는 하나의 책임이다.

> DIP (의존 역전 원칙, Dependency Inversion Principle)

- 의존 관계를 맺을 때, 변화하기 쉬운 것보다 변화하기 어려운 것에 의존해야 한다.
- 일반적으로 인터페이스를 활용하면 이 원칙은 준수된다.

***

### 객체지향 프로그래밍 언어의 구성 요소 

``` 
가볍게 읽어볼것
```

> 객체 (Object)

- 실세계에 존재하거나 생각할 수 있는 것을 말한다.
- 데이터(속성)와 이를 처리하기 위한 연산(메서드)을 결합시킨 실체이다.
- 데이터 구조와 그 위에서 수행되는 연산들을 가지고 있는 소프트웨어 모듈이다.
  - 속성(Attribute) : 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의하는 것으로서 성질, 분류, 식별, 수량 또는 현재 상태 등을 표현함
  - 메서드(Method) : 객체가 메시지를 받아 실행해야 할 때 구체적인 연산을 정의하는 것으로, 객체의 상태를 참조하거나 변경하는 수단이 됨 

> 클래스 (Class)

- 두 개 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현하는 요소, 공통된 특성과 행위를 갖는 객체의 집합이라 할 수 있다.

> 메시지 (Message)

- 객체에게 어떤 행위를 하도록 지시하는 명령 
- 객체들 간에 상호작용을 하는데 사용되는 수단으로 객체의 메서드(동작,연산)를 일으키는 외부의 요구사항이다.

***

### 디자인 패턴 ⭐⭐⭐

``` 
여러 디자인 패턴의 특징 및 개념을 적당히 이해
```

> 디자인 패턴 사용의 장단점

- 개발자들 사이의 의사소통을 원할하게 할 수 있다.
- 소프트웨어의 품질과 생상성을 향상시킬 수 있다. 
- 스프트웨어 구조 파악이 용이하다.
- 재사용을 위한 개발 시간이 단축된다.

#### 생성 패턴 (Creation Pattern)

> 추상 팩토리 패턴 (Abstract Factory)

- 서로 연관, 의존하는 객체들을 그룹으로 생성해 추상적으로 표현한다.

> 빌더 패턴 (Builder)

- 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성한다.

> 팩토리 메서드 패턴 / 가상 생성자 패턴 (Factory Method / Virtual-Constructor)

- 상위클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위클래스에서 인스턴스를 생성한다.   
- 객체를 생성하기 위한 인터페이스를 정의하여, 어떤 클래스가 인스턴스화 될 건지는 서브클래스가 결정한다. 

> 프로토타입 패턴 (Prototype) ⭐

- 프로토타입을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.

> 싱글톤 패턴 (Singleton) ⭐

- 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다.  
- 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.


#### 구조 패턴 (Structural Pattern)

> 어댑터 패턴 (Adapter) ⭐

- 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰준다.  
- 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴

> 브리지 패턴 (Bridge) 

- 구현부에서 추상층을 분리하여, 독립적으로 확장이 가능하게 하는 패턴  
- 기능과 구현을 두 개의 별도 클래스로 구현함 

> 컴포지트 패턴 (Composite)

- 여러 객체를 가진 복합, 단일 객체를 구분 없이 다룰 때 사용하는 패턴 

> 데코레이터 패턴 (Decorator) ⭐

- 상속을 사용하지 않고도 객체의 기능을 동적으로 확장해주는 패턴

> 퍼싸드 패턴 (Facade)

- 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴 (Ex. 리모컨)

> 플라이웨이트 패턴 (Flyweight)

- 공유해서 사용함으로써 메모리를 절약하는 패턴 

> 프록시 패턴 (Proxy)

- 접근이 어려운 객체를 연결해주는 인터페이스 역할을 수행하는 패턴 

#### 행위 패턴 (Behavioral Pattern)

행위의 변경, 수정 등을 위한 패턴. 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.

> 책임 연쇄 패턴 (Chain of Responsibility)

- 한 객체가 처리하지 못하면 다음 객체로 넘어가는 패턴 

> 커맨드 패턴 (Command)

- 요청에 사용되는 각종 명령어들을 추상, 구체 클래스로 분리하여 단순화함

> 인터프리터 패턴 (Interpreter)

- 언어에 문법 표현을 정의하는 패턴

> 반복자 패턴 (Iterator)

- 동일한 인터페이스를 사용하도록 하는 패턴

> 중재자 패턴 (Mediator)

- 객체간의 통제와 지시의 역할을 하는 중재자 를 두어 객체지향의 목표를 달성하게 해준다

> 메멘토 패턴 (Memento)

- 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴

> 옵저버 패턴 (Observer)

- 관찰대상의 변화를 탐지하는 패턴
- 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달
- 분산된 시스템 간에 이벤트 생성 , 발행 (Publish), 이를 수신 ( 해야 할 때 이용함

> 상태 패턴 (State)

- 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴

> 전략 패턴 (Strategy)

- 클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하는 패턴

> 템플릿 메소드 패턴 (Template Method)

- 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에 정의하는 패턴

> 방문자 패턴 (Visitor)

- 필요할 때마다 해당 클래스에 방문해서 처리하는 패턴
- 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성 한다
- 분리된 처리 기능은 각 클래스를 방문하여 수행

***

### 소프트웨어 아키텍처 패턴 

``` 
아키텍처 패턴의 종류와 각각의 특징 
```

> 레이어 패턴 (Layer Pattern)

시스템을 계층(layer)으로 구분하여 구성하는 고전적인 방법 중의 하나로 각각의 서브시스템들이 계층 구조를 이루며,
하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 됨.  
Ex. OSI 7 계층 

> 클라이언트-서버 패턴 (Client-Server Pattern) 

하나의 서버 컴포턴트와 다수의 클라이언트 컴포넌트로 구성되는 패턴으로, 
클라이언트가 서버에 요청하고 응답을 받아 사용자에게 제공하는 방식

> 파이프 필터 패턴 (Pipe-Filter Pattern)

데이터 스트림 절차의 각 단계를 필터, 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴

> 모델-뷰-컨트롤러 패턴 (Model-View-Controller Pattern)

서브시스템을 모델,뷰,컨트롤러의 세 부분으로 구조화하는 패턴

> 마스터-슬레이브 (Master-Slave Pattern)

- 일반적으로 실시간 시스템에서 사용된다.
- 마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임진다.
- 마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있다. 

***

### 순차(시퀀스) 다이어그램 구성 항목 ⭐⭐⭐

``` 
순차 다이어그램의 구성 요소의 의미를 명칭과 연결지어 암기
```

- 액터(Actor) : 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미함
- 객체(Object) : 메시지를 주고받는 객체
- 라이프라인(Lifeline) : 객체가 메모리에 존재하는 기간
- 활성 상자(Activation Box) : 객체가 메시지를 주고받으며 구동되고 있음을 표현
- 메시지(Message) : 객체가 상호 작용을 위해 주고받는 메시지

### 럼바우 분석 기법 ⭐⭐

``` 
럼바우 분석 기법은 3가지 활동에 대해 묻는 문제가 자주 출제됨 
각각의 의마가 무엇을 말하는지 구분할 정도로만 암기해두면 될듯
```

- 모든 소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 기법(OMT)이라고도 한다.
- 분석 활동은 '객체 모델링 -> 동적 모델링 -> 기능 모델링'순으로 이뤄진다.

> 객체 모델링 (Object Modeling)

- 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것이다.
- 분석 활동의 세 가지 모델 중 가장 중요하며 선행되어야 할 모델링이다. 

> 동적 모델링 (Dynamic Modeling)

- 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링

> 기능 모델링 (Functional Modeling)

- 자료 흐름도(DFD)를 이용하여 다수의 프로세스 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링


















*** 

<br>

    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}