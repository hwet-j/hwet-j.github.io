---
title:  "[정보처리기사] 필기공부3" 

categories:
  - Certificate
tags:
  - [Algorithm]

toc: true
toc_sticky: true 

date: 2023-07-07
last_modified_at: 2023-07-12
---

[참고1](https://zangzangs.tistory.com/143)
[참고2](https://devinus.tistory.com/8)
[참고3](https://record-everything.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-DFS%EC%99%80-BFS)


# 정보처리기사

## 여러가지

### 페이지 교체 알고리즘 (FIFO, LRU, LFU, NRU, NUR)

``` 
각 교체 알고리즘이 어떤 구조로 교체되는지 파악
```

페이지 교체 알고리즘에서는 페이지 부재라는 개념과 페이지 히트라는 개념이 나오는데 이 개념을 알고넘어가는것이 좋아보인다.

페이지 부재 : 페이지를 할당 받을때 이전에 존재하지 않았다면 페이지 부재

페이지 히트 : 페이지를 할당 받을때 이미 존재하여 다시 할당받을 필요가 없을 경우 페이지 히트 

페이지의 부재와 페이지 히트의 횟수에 따라 효율성이 결정된다.

Belady's Anomaly (벨레이디의 모순) : 페이지의 프레임 개수를 늘리면 page fault(페이지 부재)발생이 감소해야 하지만, 오히려 늘어나는 경우가 발생하는데 이를 Belady's Anomaly라 한다. 


#### FIFO (First In First Out : 선입선출 알고리즘)

- 페이지 교체 시 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내보내는 알고리즘 
- 구현은 간단하지만 성능은 좋지 않은 편이다.
- 페이지의 향후 참조 가능성을 고려하지 않기 때문에 비효율적인 상황이 발생

> [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 

- 1

- 1 2

- 1 2 3

- (1) 2 3 4

- (2) 3 4 1

- (3) 4 1 2

- (4) 1 2 5

- 1 2 5 (1)

- 1 2 5 (2)

- (1) 2 5 3

- (2) 5 3 4

- 5 3 5 (5)
```

먼저 올라온 페이지가 먼저 내보낸다는 것을 인지하면 구조를 이해하는 데 어려움은 없다.

#### LRU (Least Recently Used Algorithm : 최근 최소 사용 페이지)

- 페이지 교체 시 가장 오래전에 참조가 이루어진 페이지를 내보낸다.
- 시간을 기준으로 구현 가능 (카운터나 참조 비트를 이용하는 방법도 있음)
- FIFO는 메모리에 최초로 올라온 시간을 기준으로 잡는다면, LRU는 가장 오래전에 사용된 페이지를 기준으로 잡는다.

> [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 

- 7

- 7 0

- 7 0 1

- (7) 0 1 2 

- 1 2 0 (0) - 교체가 이뤄지지 않았지만 0이 마지막에 사용되었으므로 위치 이동

- (1) 2 0 3

- 2 3 0 (0)

- (2) 3 0 4

- (3) 0 4 2

- (0) 4 2 3

- (4) 2 3 0 

- 2 0 3 (3)

- 0 3 2 (2)

- (0) 3 2 1

- 3 1 2 (2)

- (3) 1 2 0

- 2 0 1 (1)

- (2) 0 1 7

- 1 7 0 (0)

- 7 0 1 (1)
```

#### OPT (Optimal Page Replacement : 최적 페이지 교체)

- 앞으로 가장 오래동안 사용하지 않을 페이지를 교체하는 알고리즘
- 모든 페이지 교체 알고리즘 중 page-falut 발생이 가장 적다.
- 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다.
- 실제로는 구현이 거의 불가능한 알고리즘으로 연구목적을 위해 사용된다.

> 예시 X 

#### LFU (Least Frequently Used : 최소 사용 빈도)

- 참조된 횟수가 가장 적은 페이지를 교체하는 알고리즘
- 참조된 횟수가 동일한 대상이 여러개 생긴다면 가장 오래동안 사용하지 않은 페이지를 교체한다.
- 가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성이 높다.(LFU의 단점)
- 초기에 많이 사용되고, 이후에 사용하지 않아도 해당 페이지는 교체 가능성이 낮다. (단점)

> [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 및 {}내 참조 횟수 표시

- 7 / {0}
  
- 7 0 / {0 0}

- 7 0 1 / {0 0 0}

- (7) 0 1 2 / {0 0 0}

- 1 2 0 / {0 0 1}  >>  참조횟수가 동일하면 참조 시기에 따라 교체 프레임이 결정되므로 보기 좋게 위치 이동 

- (1) 2 0 3 / {0 1 0}

- 2 3 0 / {0 0 2}

- (2) 3 0 4 / {0 2 0}

- 0 (3) 4 2 / {2 0 0}

- 0 (4) 2 3 / {2 0 0}

- 2 3 0 / {0 0 3}

- 2 0 3 / {0 3 1}

- 0 3 2 / {3 1 1}
 
- 0 (3) 2 1 / {3 1 0}

- 0 1 2 / {3 0 2}

- 1 2 0 / {0 2 4}

- 2 0 1 / {2 4 1}

- 2 0 (1) 7 / {2 4 0}

- 2 7 0 (0) / {2 0 5}

- 2 0 (0) 1 / {2 5 0}
```

#### MFU (Most Frequently User : 최대 사용 빈도) 

- MFU 알고리즘은 LFU 알고리즘과 반대로 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다.
- LFU 알고리즘의 구조를 이해했다면 딱히 구조를 이해하려 노력하지 않아도 이해가됨

> 예시 X

### 자료흐름도 (DFD : Data Flow Diagram)

``` 
자료흐름도의 구성요소및 개념에 대해 자주 출제
내용이 많지 않으므로 다 봐두면 좋을거같음
```

> 자료흐름도의 개념

- 데이터 흐름도(DFD)는 시스템 구성요소인 프로세스와 프로세스 간 데이터흐름을 표현하는 주요 도구
- 자료 흐름 그래프 또는 버블차트라고 부르기도 함
- 구조적 분석 기법에 사용
- 자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화


> 자료흐름도 구성요소

- 프로세스(Process) : 원
- 데이터 흐름도(Data Flow) : 화살표
- 자료 저장소(Data Store) : 직선(단선/이중선)
- 단말(Terminator) : 사각형

### 소프트웨어 아키텍처

``` 
소프트웨어 아키텍처의 설계 기본원리
소프트웨어 아키텍터의 설계 과정 
```

#### 소프트웨어 아키텍처의 설계 과정


1. 설계 목표 설정
   - 요구사항을 분석하여 전체 시스템의 설계 목표 설정
2. 시스템 타입 결정
  - 시스템과 서브시스템 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴 선택
3. 아키텍처 패턴 적용
  - 시스템의 표준 아키텍처 설계
4. 서브시스템 구체화
   - 서브시스템 간 상호작용을 위한 동작과 인터페이스 정의 
5. 검토


#### 소프트웨어 아키텍처의 설계 기본 원리 

모듈화, 추상화, 단계적 분해, 정보은닉 

> 모듈화 (Modularity) 

- 소프트웨어 성능을 향상시키거나 유지 관리가 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것 
- 자주 사용되는 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성 향상
- 모듈의 개수가 많아 지면 모듈 하나의 개발 비용이 줄어든다.
- 모듈의 크기가 커지면 모듈간의 통합 비용이 적어지는 대신 하나의 개발 비용이 커진다.

> 추상화 (Abstraction)

- 문제의 포괄적인 개념을 설계한 후 차례로 세분화 하여 구체화시켜 나가는 것 (구체화를 위한 사전단계)
- 최소의 비용으로 실제 상황에 대처 가능
- 추상화의 유형
  - 과정(흐름) 추상화 : 전반적인 흐름만 파악
  - 구조(데이터) 추상화 : 데이터의 세부적인 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체 
  - 제어(이벤트) 추상화 : 이벤트 발생의 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체 

Ex) 주문 서비스, 결제 서비스, 인증 서비스... (예시는 일부일 뿐 매우 다양함)

> 단계적 분해 (Stepwise Refinement)

- 추상화의 반복에 의해 세분화된다. (하향식 구체화라고 불린다.)
- 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료구조 등 상세한 내역은 가능한 뒤로 미뤄 진행한다.

Ex) 주문관리, 재고관리, 결제처리 ....

> 정보 은닉 (Information Hiding)

- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 추상화 -> 단계적 분해 까지 모듈화가 진행되었다면, 마지막으로 정보은닉을 진행한다.
- 어떤 모듈이 소프트웨어 기능을 수행하는데 반드시 필요한 기능이 있어 정보 은닉된 모듈과 커뮤니케이션할 필요가 있을 때 필요한 정보만 인터페이스를 통해 주고 받는다.
- 정보 은닉으로 독립적으로 수행가능하고, 각각의 모듈이 서로 접근할 수 없도록 차단한다.

Ex) 알약으로 만들어진 감기약은 어떠한 재료가 있는지 알지 못하지만 외부에서 접근이 되지 않고, 감기에 걸렸을때 복용해야하는 정보만 알고있으면 사용가능하다.

### DFS와 BFS

``` 
어떤 순서로 탐색이 이뤄지는지 출제가 종종되는듯함 
```

#### 깊이우선탐색 (DFS : Depth First Search)

트리나 그래프에서 한 루트로 탐색하다가 특정 상황에서 최대한 깊숙이 들어가서 확인하고 다시 돌아가 다른 루트를 탐색하는 방식이다.

최대한 안쪽으로 이동하면서 갈림길이 나타날 때마다 다른 길이 존재한다는 정보만 기록하고 지나간 길을 지워나간다.
가장 안쪽으로 이동하여 더 이상 이동할 길이 없다면, 되돌아간다. 

![image](https://github.com/hwet-j/hwet-j.github.io/assets/81364742/a0a6150d-5e21-4148-ab76-3990187e1a18)

``` 
1) 시작 정점 A를 스택에 넣고 방문 처리한다. A
2) 스택의 최상단 노드 A는 꺼내 출력하고, 그 인접 노드인 C, B를 스택에 넣고 방문처리한다.(위 그림과 같이 직관적인 순서로 나타내기 위해 알파벳 역순으로 스택에 삽입하였다.) C B
3) 스택의 최상단 노드인 B는 꺼내 출력하고, 그 인접 노드인 E, D를 스택에 넣고 방문처리한다. C E D
4) 스택의 최상단 노드인 D는 꺼내 출력하고, 그 인접 노드인 I, H를 스택에 넣고 방문처리한다. C E I H
5) 스택의 최상단 노드인 H는 꺼내 출력한다. 방문하지 않은 인접 노드가 없으므로 스택에는 아무것도 넣지 않는다. C E I
6) 위 과정을 스택에 아무것도 남지 않을 때까지 반복한다.
```

#### 너비우선탐색 (BFS : Breath First Search)

![image](https://github.com/hwet-j/hwet-j.github.io/assets/81364742/e853b81e-bbe6-4f96-9c32-c83ebc17ce01)

``` 
1) 시작 정점 A를 큐에 넣고 방문 처리한다. A
2) 큐에서 A를 꺼내고, 인접 노드 B, C를 큐에 삽입 후 방문 처리한다. B C
3) 큐에서 B를 꺼내고, 인접 노드 D, E를 큐에 삽입 후 방문 처리한다. C D E
4) 큐에서 C를 꺼내고, 인접 노드 F, G를 큐에 삽입 후 방문 처리한다. D E F G
5) 위 과정을 스택에 아무것도 남지 않을 때까지 반복한다.
```

`꽤 많은 페이지를 참고했으나 자세하고 일관되지 않아 쉬운 구조는 풀이가능할듯하지만, 복잡해지면 공부하는것 보다 그냥 틀리는게 나아보임`








***






*** 

<br>

    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}