---
title:  "[정보처리기사] 필기공부3" 

categories:
  - Certificate
tags:
  - [Algorithm]

toc: true
toc_sticky: true 

date: 2023-07-07
last_modified_at: 2023-07-10
---

(참고)[https://zangzangs.tistory.com/143]
(참고)[https://devinus.tistory.com/8]


# 정보처리기사

## 여러가지

### 페이지 교체 알고리즘 (FIFO, LRU, LFU, NRU, NUR)

``` 
각 교체 알고리즘이 어떤 구조로 교체되는지 파악
```

페이지 교체 알고리즘에서는 페이지 부재라는 개념과 페이지 히트라는 개념이 나오는데 이 개념을 알고넘어가는것이 좋아보인다.

페이지 부재 : 페이지를 할당 받을때 이전에 존재하지 않았다면 페이지 부재

페이지 히트 : 페이지를 할당 받을때 이미 존재하여 다시 할당받을 필요가 없을 경우 페이지 히트 

페이지의 부재와 페이지 히트의 횟수에 따라 효율성이 결정된다.

Belady's Anomaly (벨레이디의 모순) : 페이지의 프레임 개수를 늘리면 page fault(페이지 부재)발생이 감소해야 하지만, 오히려 늘어나는 경우가 발생하는데 이를 Belady's Anomaly라 한다. 


#### FIFO (First In First Out : 선입선출 알고리즘)

- 페이지 교체 시 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내보내는 알고리즘 
- 구현은 간단하지만 성능은 좋지 않은 편이다.
- 페이지의 향후 참조 가능성을 고려하지 않기 때문에 비효율적인 상황이 발생

> [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 

- 1

- 1 2

- 1 2 3

- (1) 2 3 4

- (2) 3 4 1

- (3) 4 1 2

- (4) 1 2 5

- 1 2 5 (1)

- 1 2 5 (2)

- (1) 2 5 3

- (2) 5 3 4

- 5 3 5 (5)
```

먼저 올라온 페이지가 먼저 내보낸다는 것을 인지하면 구조를 이해하는 데 어려움은 없다.

#### LRU (Least Recently Used Algorithm : 최근 최소 사용 페이지)

- 페이지 교체 시 가장 오래전에 참조가 이루어진 페이지를 내보낸다.
- 시간을 기준으로 구현 가능 (카운터나 참조 비트를 이용하는 방법도 있음)
- FIFO는 메모리에 최초로 올라온 시간을 기준으로 잡는다면, LRU는 가장 오래전에 사용된 페이지를 기준으로 잡는다.

> [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 

- 7

- 7 0

- 7 0 1

- (7) 0 1 2 

- 1 2 0 (0) - 교체가 이뤄지지 않았지만 0이 마지막에 사용되었으므로 위치 이동

- (1) 2 0 3

- 2 3 0 (0)

- (2) 3 0 4

- (3) 0 4 2

- (0) 4 2 3

- (4) 2 3 0 

- 2 0 3 (3)

- 0 3 2 (2)

- (0) 3 2 1

- 3 1 2 (2)

- (3) 1 2 0

- 2 0 1 (1)

- (2) 0 1 7

- 1 7 0 (0)

- 7 0 1 (1)
```

#### OPT (Optimal Page Replacement : 최적 페이지 교체)

- 앞으로 가장 오래동안 사용하지 않을 페이지를 교체하는 알고리즘
- 모든 페이지 교체 알고리즘 중 page-falut 발생이 가장 적다.
- 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다.
- 실제로는 구현이 거의 불가능한 알고리즘으로 연구목적을 위해 사용된다.

> 예시 X 

#### LFU (Least Frequently Used : 최소 사용 빈도)

- 참조된 횟수가 가장 적은 페이지를 교체하는 알고리즘
- 참조된 횟수가 동일한 대상이 여러개 생긴다면 가장 오래동안 사용하지 않은 페이지를 교체한다.
- 가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성이 높다.(LFU의 단점)
- 초기에 많이 사용되고, 이후에 사용하지 않아도 해당 페이지는 교체 가능성이 낮다. (단점)

> [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 및 {}내 참조 횟수 표시

- 7 / {0}
  
- 7 0 / {0 0}

- 7 0 1 / {0 0 0}

- (7) 0 1 2 / {0 0 0}

- 1 2 0 / {0 0 1}  >>  참조횟수가 동일하면 참조 시기에 따라 교체 프레임이 결정되므로 보기 좋게 위치 이동 

- (1) 2 0 3 / {0 1 0}

- 2 3 0 / {0 0 2}

- (2) 3 0 4 / {0 2 0}

- 0 (3) 4 2 / {2 0 0}

- 0 (4) 2 3 / {2 0 0}

- 2 3 0 / {0 0 3}

- 2 0 3 / {0 3 1}

- 0 3 2 / {3 1 1}
 
- 0 (3) 2 1 / {3 1 0}

- 0 1 2 / {3 0 2}

- 1 2 0 / {0 2 4}

- 2 0 1 / {2 4 1}

- 2 0 (1) 7 / {2 4 0}

- 2 7 0 (0) / {2 0 5}

- 2 0 (0) 1 / {2 5 0}
```

#### MFU (Most Frequently User : 최대 사용 빈도) 

- MFU 알고리즘은 LFU 알고리즘과 반대로 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다.
- LFU 알고리즘의 구조를 이해했다면 딱히 구조를 이해하려 노력하지 않아도 이해가됨

> 예시 X

### 자료흐름도 (DFD : Data Flow Diagram)

``` 
자료흐름도의 구성요소및 개념에 대해 자주 출제
내용이 많지 않으므로 다 봐두면 좋을거같음
```

> 자료흐름도의 개념

- 데이터 흐름도(DFD)는 시스템 구성요소인 프로세스와 프로세스 간 데이터흐름을 표현하는 주요 도구
- 자료 흐름 그래프 또는 버블차트라고 부르기도 함
- 구조적 분석 기법에 사용
- 자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화


> 자료흐름도 구성요소

- 프로세스(Process) : 원
- 데이터 흐름도(Data Flow) : 화살표
- 자료 저장소(Data Store) : 직선(단선/이중선)
- 단말(Terminator) : 사각형

### 소프트웨어 아키텍처

``` 
소프트웨어 아키텍처의 설계 기본원리
소프트웨어 아키텍터의 설계 과정 
```

#### 소프트웨어 아키텍처의 설계 과정


1. 설계 목표 설정
   - 요구사항을 분석하여 전체 시스템의 설계 목표 설정
2. 시스템 타입 결정
  - 시스템과 서브시스템 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴 선택
3. 아키텍처 패턴 적용
  - 시스템의 표준 아키텍처 설계
4. 서브시스템 구체화
   - 서브시스템 간 상호작용을 위한 동작과 인터페이스 정의 
5. 검토


#### 소프트웨어 아키텍처의 설계 기본 원리 

> 모듈화 (Modularity) 

- 소프트웨어 성능을 향상시키거나 유지 관리가 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것 
- 자주 사용되는 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성 향상

> 추상화 (Abstraction)

- 문제의 포괄적인 개념을 설계한 후 차례로 세분화 하여 구체화시켜 나가는 것 
- 최소의 비용으로 실제 상황에 대처 가능
- 추상화의 유형
  - 과정 추상화 : 전반적인 흐름만 파악
  - 데이터 추상화 : 데이터의 세부적인 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체 
  - 제어 추상화 : 이벤트 발생의 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체 

> 단계적 분해 ()














***






*** 

<br>

    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}