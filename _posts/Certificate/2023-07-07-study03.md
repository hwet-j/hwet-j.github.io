---
title:  "[정보처리기사] 필기공부3" 

categories:
  - Certificate
tags:
  - [Algorithm]

toc: true
toc_sticky: true 

date: 2023-07-07
last_modified_at: 2023-07-12
---

[참고1](https://zangzangs.tistory.com/143)
[참고2](https://devinus.tistory.com/8)
[참고3](https://record-everything.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-DFS%EC%99%80-BFS)


# 정보처리기사

## 여러가지

### 페이지 교체 알고리즘 (FIFO, LRU, LFU, NRU, NUR)

``` 
각 교체 알고리즘이 어떤 구조로 교체되는지 파악
```

페이지 교체 알고리즘에서는 페이지 부재라는 개념과 페이지 히트라는 개념이 나오는데 이 개념을 알고넘어가는것이 좋아보인다.

페이지 부재 : 페이지를 할당 받을때 이전에 존재하지 않았다면 페이지 부재

페이지 히트 : 페이지를 할당 받을때 이미 존재하여 다시 할당받을 필요가 없을 경우 페이지 히트 

페이지의 부재와 페이지 히트의 횟수에 따라 효율성이 결정된다.

Belady's Anomaly (벨레이디의 모순) : 페이지의 프레임 개수를 늘리면 page fault(페이지 부재)발생이 감소해야 하지만, 오히려 늘어나는 경우가 발생하는데 이를 Belady's Anomaly라 한다. 


#### FIFO (First In First Out : 선입선출 알고리즘)

- 페이지 교체 시 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내보내는 알고리즘 
- 구현은 간단하지만 성능은 좋지 않은 편이다.
- 페이지의 향후 참조 가능성을 고려하지 않기 때문에 비효율적인 상황이 발생

> [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 

- 1

- 1 2

- 1 2 3

- (1) 2 3 4

- (2) 3 4 1

- (3) 4 1 2

- (4) 1 2 5

- 1 2 5 (1)

- 1 2 5 (2)

- (1) 2 5 3

- (2) 5 3 4

- 5 3 5 (5)
```

먼저 올라온 페이지가 먼저 내보낸다는 것을 인지하면 구조를 이해하는 데 어려움은 없다.

#### LRU (Least Recently Used Algorithm : 최근 최소 사용 페이지)

- 페이지 교체 시 가장 오래전에 참조가 이루어진 페이지를 내보낸다.
- 시간을 기준으로 구현 가능 (카운터나 참조 비트를 이용하는 방법도 있음)
- FIFO는 메모리에 최초로 올라온 시간을 기준으로 잡는다면, LRU는 가장 오래전에 사용된 페이지를 기준으로 잡는다.

> [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 

- 7

- 7 0

- 7 0 1

- (7) 0 1 2 

- 1 2 0 (0) - 교체가 이뤄지지 않았지만 0이 마지막에 사용되었으므로 위치 이동

- (1) 2 0 3

- 2 3 0 (0)

- (2) 3 0 4

- (3) 0 4 2

- (0) 4 2 3

- (4) 2 3 0 

- 2 0 3 (3)

- 0 3 2 (2)

- (0) 3 2 1

- 3 1 2 (2)

- (3) 1 2 0

- 2 0 1 (1)

- (2) 0 1 7

- 1 7 0 (0)

- 7 0 1 (1)
```

#### OPT (Optimal Page Replacement : 최적 페이지 교체)

- 앞으로 가장 오래동안 사용하지 않을 페이지를 교체하는 알고리즘
- 모든 페이지 교체 알고리즘 중 page-falut 발생이 가장 적다.
- 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다.
- 실제로는 구현이 거의 불가능한 알고리즘으로 연구목적을 위해 사용된다.

> 예시 X 

#### LFU (Least Frequently Used : 최소 사용 빈도)

- 참조된 횟수가 가장 적은 페이지를 교체하는 알고리즘
- 참조된 횟수가 동일한 대상이 여러개 생긴다면 가장 오래동안 사용하지 않은 페이지를 교체한다.
- 가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성이 높다.(LFU의 단점)
- 초기에 많이 사용되고, 이후에 사용하지 않아도 해당 페이지는 교체 가능성이 낮다. (단점)

> [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1]

``` 
# 페이지 프레임 3개 - ()괄호를 사용하여 제거된 숫자 표현 및 {}내 참조 횟수 표시

- 7 / {0}
  
- 7 0 / {0 0}

- 7 0 1 / {0 0 0}

- (7) 0 1 2 / {0 0 0}

- 1 2 0 / {0 0 1}  >>  참조횟수가 동일하면 참조 시기에 따라 교체 프레임이 결정되므로 보기 좋게 위치 이동 

- (1) 2 0 3 / {0 1 0}

- 2 3 0 / {0 0 2}

- (2) 3 0 4 / {0 2 0}

- 0 (3) 4 2 / {2 0 0}

- 0 (4) 2 3 / {2 0 0}

- 2 3 0 / {0 0 3}

- 2 0 3 / {0 3 1}

- 0 3 2 / {3 1 1}
 
- 0 (3) 2 1 / {3 1 0}

- 0 1 2 / {3 0 2}

- 1 2 0 / {0 2 4}

- 2 0 1 / {2 4 1}

- 2 0 (1) 7 / {2 4 0}

- 2 7 0 (0) / {2 0 5}

- 2 0 (0) 1 / {2 5 0}
```

#### MFU (Most Frequently User : 최대 사용 빈도) 

- MFU 알고리즘은 LFU 알고리즘과 반대로 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다.
- LFU 알고리즘의 구조를 이해했다면 딱히 구조를 이해하려 노력하지 않아도 이해가됨

> 예시 X

### 자료흐름도 (DFD : Data Flow Diagram)

``` 
자료흐름도의 구성요소및 개념에 대해 자주 출제
내용이 많지 않으므로 다 봐두면 좋을거같음
```

> 자료흐름도의 개념

- 데이터 흐름도(DFD)는 시스템 구성요소인 프로세스와 프로세스 간 데이터흐름을 표현하는 주요 도구
- 자료 흐름 그래프 또는 버블차트라고 부르기도 함
- 구조적 분석 기법에 사용
- 자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화


> 자료흐름도 구성요소

- 프로세스(Process) : 원
- 데이터 흐름도(Data Flow) : 화살표
- 자료 저장소(Data Store) : 직선(단선/이중선)
- 단말(Terminator) : 사각형

### 소프트웨어 아키텍처

``` 
소프트웨어 아키텍처의 설계 기본원리
소프트웨어 아키텍터의 설계 과정 
```

#### 소프트웨어 아키텍처의 설계 과정


1. 설계 목표 설정
   - 요구사항을 분석하여 전체 시스템의 설계 목표 설정
2. 시스템 타입 결정
  - 시스템과 서브시스템 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴 선택
3. 아키텍처 패턴 적용
  - 시스템의 표준 아키텍처 설계
4. 서브시스템 구체화
   - 서브시스템 간 상호작용을 위한 동작과 인터페이스 정의 
5. 검토


#### 소프트웨어 아키텍처의 설계 기본 원리 

모듈화, 추상화, 단계적 분해, 정보은닉 

> 모듈화 (Modularity) 

- 소프트웨어 성능을 향상시키거나 유지 관리가 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것 
- 자주 사용되는 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성 향상
- 모듈의 개수가 많아 지면 모듈 하나의 개발 비용이 줄어든다.
- 모듈의 크기가 커지면 모듈간의 통합 비용이 적어지는 대신 하나의 개발 비용이 커진다.

> 추상화 (Abstraction)

- 문제의 포괄적인 개념을 설계한 후 차례로 세분화 하여 구체화시켜 나가는 것 (구체화를 위한 사전단계)
- 최소의 비용으로 실제 상황에 대처 가능
- 추상화의 유형
  - 과정(흐름) 추상화 : 전반적인 흐름만 파악
  - 구조(데이터) 추상화 : 데이터의 세부적인 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체 
  - 제어(이벤트) 추상화 : 이벤트 발생의 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체 

Ex) 주문 서비스, 결제 서비스, 인증 서비스... (예시는 일부일 뿐 매우 다양함)

> 단계적 분해 (Stepwise Refinement)

- 추상화의 반복에 의해 세분화된다. (하향식 구체화라고 불린다.)
- 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료구조 등 상세한 내역은 가능한 뒤로 미뤄 진행한다.

Ex) 주문관리, 재고관리, 결제처리 ....

> 정보 은닉 (Information Hiding)

- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 추상화 -> 단계적 분해 까지 모듈화가 진행되었다면, 마지막으로 정보은닉을 진행한다.
- 어떤 모듈이 소프트웨어 기능을 수행하는데 반드시 필요한 기능이 있어 정보 은닉된 모듈과 커뮤니케이션할 필요가 있을 때 필요한 정보만 인터페이스를 통해 주고 받는다.
- 정보 은닉으로 독립적으로 수행가능하고, 각각의 모듈이 서로 접근할 수 없도록 차단한다.

Ex) 알약으로 만들어진 감기약은 어떠한 재료가 있는지 알지 못하지만 외부에서 접근이 되지 않고, 감기에 걸렸을때 복용해야하는 정보만 알고있으면 사용가능하다.

### DFS와 BFS

``` 
어떤 순서로 탐색이 이뤄지는지 출제가 종종되는듯함 
```

#### 깊이우선탐색 (DFS : Depth First Search)

트리나 그래프에서 한 루트로 탐색하다가 특정 상황에서 최대한 깊숙이 들어가서 확인하고 다시 돌아가 다른 루트를 탐색하는 방식이다.

최대한 안쪽으로 이동하면서 갈림길이 나타날 때마다 다른 길이 존재한다는 정보만 기록하고 지나간 길을 지워나간다.
가장 안쪽으로 이동하여 더 이상 이동할 길이 없다면, 되돌아간다. 

![image](https://github.com/hwet-j/hwet-j.github.io/assets/81364742/a0a6150d-5e21-4148-ab76-3990187e1a18)

``` 
1) 시작 정점 A를 스택에 넣고 방문 처리한다. A
2) 스택의 최상단 노드 A는 꺼내 출력하고, 그 인접 노드인 C, B를 스택에 넣고 방문처리한다.(위 그림과 같이 직관적인 순서로 나타내기 위해 알파벳 역순으로 스택에 삽입하였다.) C B
3) 스택의 최상단 노드인 B는 꺼내 출력하고, 그 인접 노드인 E, D를 스택에 넣고 방문처리한다. C E D
4) 스택의 최상단 노드인 D는 꺼내 출력하고, 그 인접 노드인 I, H를 스택에 넣고 방문처리한다. C E I H
5) 스택의 최상단 노드인 H는 꺼내 출력한다. 방문하지 않은 인접 노드가 없으므로 스택에는 아무것도 넣지 않는다. C E I
6) 위 과정을 스택에 아무것도 남지 않을 때까지 반복한다.
```

#### 너비우선탐색 (BFS : Breath First Search)

![image](https://github.com/hwet-j/hwet-j.github.io/assets/81364742/e853b81e-bbe6-4f96-9c32-c83ebc17ce01)

``` 
1) 시작 정점 A를 큐에 넣고 방문 처리한다. A
2) 큐에서 A를 꺼내고, 인접 노드 B, C를 큐에 삽입 후 방문 처리한다. B C
3) 큐에서 B를 꺼내고, 인접 노드 D, E를 큐에 삽입 후 방문 처리한다. C D E
4) 큐에서 C를 꺼내고, 인접 노드 F, G를 큐에 삽입 후 방문 처리한다. D E F G
5) 위 과정을 스택에 아무것도 남지 않을 때까지 반복한다.
```

`꽤 많은 페이지를 참고했으나 자세하고 일관되지 않아 쉬운 구조는 풀이가능할듯하지만, 복잡해지면 공부하는것 보다 그냥 틀리는게 나아보임`

### 소프트웨어 개발 방법론 ⭐⭐

``` 
객체지향, 컴포넌트, 애자일 관련하여 자주 출제되며 다른 방법론에 대해서도 출제되기는 한다. 
꽤나 자주 출제되므로 전체적으로 암기가 필요해보임
```

`구정객컴에제`

- 구조적 방법론
- 정보공학 방법론
- 객체지향 방법론
- 컴포넌트 기반 방법론
- 애자일 방법론
- 제품 계열 방법론

#### 구조적 방법론

- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리(Process) 중심의 방법론

타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 단계

`분설구테유` 정도로 암기하면 문제풀이 도움될듯함

#### 정보공학 방법론

- 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성있게 통합 및 적용하는 자료(Data) 중심의 방법론이다.
- 정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합하다.

#### 컴포넌트 기반 방법론

- 기존 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론이다.
- 컴포넌트의 재사용이 가능하여 시간과 노력을 절감할 수 있다.
- 새로운 기능을 추가하는 것이 간단하여 확장성이 보장된다.
- 유지 보수 비용을 최소화하고 생산성 및 품질을 향상시킬 수 있다.

#### 객체지향 분석의 방법론

- 럼바우 방법 (Rumbaugh) : 가장 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법
- 부치 방법 (Booch) : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함
- Jacobson 방법 : Use Case를 강조하여 사용하는 분석방법
- Coad와 Yourdon 방법 : E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체식별, 구조식별, 주제정의, 속성과 인스턴스 연결정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
- Wrifs-Brock 방법 : 분석과 설계 간의 구분이 없고, 고객명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법


### OSI 참조 모델  ⭐⭐⭐

``` 
OSI 7계층의 각 계층이름과 순서 및 구별 가능할 정도로 암기
```

OSI 7계층은 1~3계층을 하위 계층, 4~7계층을 상위 계층 이라고 한다.

- 하위 계층 : 물리 -> 데이터 링크 -> 네트워크
- 상위 계층 : 전송 -> 세션 -> 표현 -> 응용

| 계층                             | 설명                                                                                                                                                                                                  |
|--------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 물리 계층<br>(Physical Layer)      | 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의함                                                                                                                                       |
| 데이터 링크 계층<br>(Data Link Layer) | 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당함. <br> 송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어 기능을 함. <br> 프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능을 함. <br> 오류의 검출과 회복을 위한 오류 제어 기능을 함.    |
| 네트워크 계층<br>(Network Layer)     | 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 함. <br> 네트워크 연결을 설정, 유지, 해제하는 기능을 함. <br> 경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행.                                                          |
| 전송 계층<br>(Transport Layer)     | 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능하게 함 <br> 종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능을 함<br>주소 설정, 다중화(분할 및 재조립), 오류제어, 흐름제어를 수행함                                       |
| 세션 계층<br>(Session Layer)       | 송/수신 측 간의 관련성을 유지하고 대화 제어를 담당함<br> 대화 구성 및 동기 제어, 데이터 교환 관리 기능을 함                                                                                                                                   |
| 표현 계층<br>(Presestation Layer)  | 응용 계층으로부터 받은 데이터를 세션 계층으로 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함<br> 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층<br> 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포멧)변환, 문맥 관리 기능을 함 |
| 응용 계층<br>(Application Layer)   | 사용자(응용 프로그램)가 OSI환경에 접근할 수 있도록 서비스를 제공함                                                                                                                                                             |

### 네트워크 관련 장비 ⭐

``` 
이해가 어렵지 않으니 각각 어떤 기능을 가지는지 확인
```

> 네트워크 인터페이스 카드(NIC : Network Interface Card)

- 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치로, 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경함

> 허브 (Hub)

- 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터의 역할도 포함함-

> 리피터 (Repeater)

- 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행함

> 브리지 (Bridge)

- LAN과 LAN을 연결하거나 LAN안에서의 컴퓨터 그룹(세그먼트) 연결하는 기능을 수행함
- 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있음

> 스위치 (Switch)

- 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치
- 하드웨어를 기반으로 처리하므로 전송 속도가 빠름

> 라우터 (Router)

- 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것으로, 서로 다른 LAN이나 LAN과 WAN의 연결도 수행함

WAN : LAN과 LAN을 연결하는 광범위 대규모 네트워크

> 게이트웨이 (Gateway)

- 전 계층(1~7계층)의 프로토콜 구조가 다른 네트워크의 연결을 수행함
- LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 함

### 프로토콜 ⭐⭐⭐

``` 
적당히 종류별로 어디에 속하는지만 외워두면 될 거같다.
하나에 대하여 자세히 물어보는 문제가 있으면 문제로 공부..
```

#### 응용 계층의 주요 프로토콜

- FTP (File Transfer Protocol)
- SMTP (Simple Mail Tranfer Protocol)
- TELNET
- SNMP (Simple Network Management Protocol)
- DNS (Domain Name System)
- HTTP (Hyper Test Transfer Protocol)

#### 전송 계층의 주요 프로토콜

- TCP (Transmission Control Protocol)
- UDP (User Datagram Protocol)
- RTCP (Real-Time Control Protocol)

#### 인터넷 계층의 주요 프로토콜

- IP (Internet Protocol)
- ICMP (인터넷 제어 메시지 프로토콜 : Internet Control Message Protocol)
- IGMP (인터넷 그룹관리 프로토콜 : Internet Group Management Protocol)
- ARP (주소 분석 프로토콜 : Address Resolution Protocol)
- RARP (Revers Address Resolution Protocol)

#### 네트워크 액세스 계층의 주요 프로토콜

- Ethernet (IEEE 802.3)
- IEEE 802
- HDLC
- X.25
- RS-232C

### CASE ⭐⭐

소프트웨어 개발과정에서 사용되는 요구 분석, 설계 , 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것이다.ㅏ

- 객제지향 시스템, 구조적 시스템 등 다양한 시스템에서활용되는 자동화 도구(CASE Tool)이다.
- 소프트웨어, 하드웨어, 데이터베이스, 테스트 등을 통합하여 소프트웨어를 개발하는 환경을 조성한다.
- 소프트웨어 생명 주기의 전체 단계를 연결해 주고 자동화해 주는 통합된 도구를 제공해 주는 기술이다.
- 소프트웨어 개발 도구와 방법론이 결합된 것으로, 정형화된 구조 및 방법(메커니즘)을 소프트웨어 개발에 적용하여 생산성 향상을 구현하는 공학 기법이다.
- 소프트웨어 개발의 모든 단계에 걸쳐 일관된 방법론을제공하는 자동화 도구들을 지원하고, 개발자들은 이 도구를 사용하여 소프트웨어 개발의 표준화를 지향하며,자동화의 이점을 얻을 수 있게 해준다.
- CASE의 주요 기능 : 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원 등








***






*** 

<br>

    📢 개인 공부 및 정리용 블로그로, 틀리거나 주관적인 의견이 들어갈 수 있습니다.
    잘못된 부분이 있다면, 언제든지 댓글이나 메일로 알려주시면 참고하겠습니다. 🔔

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}