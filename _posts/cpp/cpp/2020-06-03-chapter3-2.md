---
title:  "C++ Chapter 3.2 : 이진수" 

categories:
  - Cpp
tags:
  - [Programming, Cpp]

toc: true
toc_sticky: true

date: 2020-06-03
last_modified_at: 2020-06-03
---

인프런에 있는 홍정모 교수님의 **홍정모의 따라 하며 배우는 C++** 강의를 듣고 정리한 필기입니다. 😀    
[🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!](https://www.inflearn.com/course/following-c-plus)
{: .notice--warning}

<br>

- 주의 사항
    - C++은 제곱 연산자가 없다.
    - x^2는 잘못된 것.
        - ^는 비트 연산자에서 XOR이다.

## 이진수 -> 십진수 변환

$$01011110= 0 ×2^7 + 1 ×2^6 + 0 ×2^5 + 1 ×2^4 +  1 ×2^3 + 1 ×2^2 + 1 ×2^1 + 0 ×2^0 $$

$$=64 + 16 + 8 + 4 +2$$

$$ ∴ 01011110 = 94$$

<br>

## 십진수 -> 이진수 변환
$$148 = 10010100$$

### 첫 번째 방법

![image](https://user-images.githubusercontent.com/42318591/83949520-3b642600-a85f-11ea-814c-1f0ac8ead3d2.png){: width="70%" height="70%"}{: .align-center}

- 몫이 0이 될 때까지 몫을 `2` 로 계속 나누는 행위를 반복한다.
- 매 나눗셈마다 도출 된 나머지를 <u>역순</u>으로 출력하면 이진수 완성 !


### 두 번째 방법

![image](https://user-images.githubusercontent.com/42318591/83949878-4029d980-a861-11ea-9797-5d84dae38caf.png){: width="70%" height="70%"}{: .align-center}

1. num보다 작거나 같은 `2의 제곱들` 中 가장 큰 수 찾기
    - 이를 X라고 하겠다. 2^n = X
        - num = 128,  X = 128,  n = 7
2. num ≥ X 비교한다. 
    - true면
        1. `1` 출력
        2. num = num - X
            - 148 - 128 = 20
        3. n = n - 1
        4. X = 2^n
    - false면
        1. `0` 출력
        2. n = n - 1
        3. X = 2^n
3. X = 0 이 될 때까지 2. 을 반복한다.  
    - 총 초기 n + 1번 반복
- input = 148 이라면 최종적으로 `10010100` 이 출력 될 것.

```cpp
#include <iostream>

using namespace std;

int main()
{
    const int input = 148;  // input 값은 상수로 설정했다. 보존하기 위해.
    int num = input;  // num 초기값은 input값.
    int x = 1, n = 0; // x, n 초기값
    
		/* num보다 작거나 같은 2의 제곱들 中 가장 큰 수 찾기 ------------------------*/
    while(true)
    {
        n++;
        x = x * 2;
        if (num < x)
        {
            n--;
            x = x / 2;
            break;
        }
    }
		/* 최종적으로 x = 128, n = 7이 될 것 ---------------------------------------*/
    
		
    for(int i = 1; i <= n + 1;  i++)  // n + 1 번 반복
    {
        if (num >= x)
        {
            cout << 1 ; // 1 출력 
            num = num - x; // 이에 경우 num값 업데이트 
            x = x / 2;
        }
        else
        {
            cout << 0;  // 0 출력
            x = x / 2;
        }
    }
    
    cout << endl;

    return 0;
}
```

<br>

## 이진수끼리의 덧셈

![image](https://user-images.githubusercontent.com/42318591/83949904-972fae80-a861-11ea-9639-5db7dab9ade1.png){: width="50%" height="50%"}{: .align-center}

<br>

## 음의 십진수 -> 음의 이진수 변환
1. 절대값 취하기
- `-5` 의 절대값 `5`
2. 이진수로 변환하기
- `5`의 이진수 = `00000101`
3. 보수 취하기
- `11111010`
4. 1을 더해주기
- `11111011` 이게 바로 `-5` 의 이진수
  - <u>1 을 더해주는 이유는 0이 +0, -0 두가지로 표현되는 것을 막기 위해서</u>
    - +0 → 00000000
      - 1 더해서 다 밀어주고
    - -0 → 11111111
      - 1 더해서 -0을 하나밖에 없는 진짜 0으로 만든다. 0을 1개만 존재하게 하기 위하여.

<br>

## 음의 이진수 -> 음의 십진수 변환

1. 1을 빼주기
- `11111011` - `00000001` = `11111010`
2. 보수 취하기
- `11111010` 의 보수 → `00000101`
- 1~2번까지는 양의 이진수로 변환하는 과정
3. 십진수로 변환하기
- `00000101` = 1*4 + 1*1 = `5`
4. sign 비트 고려하여 - 붙여주기
- `-5`

<br>

## signed Vs. unsigned

$$10011110$$

- signed →  `-98`
    - signed 비트이므로 맨 앞 비트 1개는 부호를 뜻한다.
    - 1이므로 음수.
    - 음의 이진수 → 음의 십진수 방식대로 변환해주어야 한다.
- unsigned → `158`
    - signed 비트이므로 sign비트는 존재하지 않는다.
    - 그냥 `10011110` = 128 + 32 + 16 + 8 + 4 + 2  = 158
- 이렇게 같은 이진수라도 signed냐 unsigned냐에 따라 값이 다르다.

***
<br>

    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}