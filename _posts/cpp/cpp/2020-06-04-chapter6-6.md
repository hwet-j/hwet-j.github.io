---
title:  "C++ Chapter 6.6 : 포인터의 기본적인 사용법" 

categories:
  - Cpp
tags:
  - [Programming, Cpp]

toc: true
toc_sticky: true

date: 2020-06-04
last_modified_at: 2020-06-04
---
인프런에 있는 홍정모 교수님의 **홍정모의 따라 하며 배우는 C++** 강의를 듣고 정리한 필기입니다. 😀    
[🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!](https://www.inflearn.com/course/following-c-plus)
{: .notice--warning}

<br>


## 포인터
메모리 주소를 담는 변수를 뜻한다.

`&`
- <u>변수</u> 앞에 붙으면 그 변수의 주소 

`*` 
- <u>포인터 변수</u> 앞에 붙으면 그 포이터 변수가 담고 있는 주소에 담긴 데이터
- 간접 참조 

<br>

## 포인터 변수의 선언
포인터 선언시 `가리킬 메모리의 데이터 타입 + *`

*ex) int *, double \**

```cpp
int x = 5;
int * ptr = &x;  
*ptr = 7;  // x 값이 7로 변한다. x=7 이나 마찬가지.
```
`int * ptr = &x;`
- int 타입의 변수의 주소를 담을 수 있는 포인터라는 의미에서 int *
- 포인터 변수 ptr은 int형 변수인 x의 주소로 초기화 됐다.
- <u>포인터 ptr은 x 를 가리키고 있다.</u>

`*ptr = 7;`
- ptr은 현재 x의 주소를 담고 있는데 `*`를 포인터 앞에 붙이면 x의 데이터를 참조할 수 있게 된다.
- 동시에 x의 값이 7로 바뀐다. 
- 포인터 선언시 데이터 타입을 적어줘야 하는 이유는 이렇게 간접 참조할때 어떤 타입으로 값을 가져올지 정보가 필요하기 때문이다. 

<br>

## 포인터를 사용하는 이유
- 많은 양의 데이터를 <u>복사</u>할땐 연산 시간도 늘어나고 써야하는 메모리 공간도 늘어난다.
  - 이때 그냥 포인터로 간접 참조하거나 포인터에 주소를 두고 주소 정보만 복사해서 넘기면 내용물들을 복사할 필요가 없게 되어 효율적이다.

<br>

## 포인터의 크기

### sizeof(ptr)

- 32 bit 시스템에서는 int * 이든 double *이든 크기는 4byte다.
  - 32bit = 4byte. 4byte의 주소 체계를 쓰기 때문
- 64 bit 시스템에서는 int * 이든 double *이든  크기는 8byte다.
  - 64bit = 8byte. 8byte의 주소 체계를 쓰기 때문

<br>

## nullptr
- C언어에선 `NULL`로 쓰여쓴데 C++에선 `nullptr`로 쓰임
- 포인터(주소) 값이 없다는 의미. 즉, 가르키고 있는 대상이 현재 없음. 아무 주소도 담고 있지 않음.
- 다른 것을 가리키고 있지 않은 포인터의 경우 nullptr로 꼭 초기화 해주는 습관을 들이자.
  - if문을 두어 포인터가 nullptr 일 경우 다른 작동을 하게끔 할 수도 있고
  - `double * ptr = nullptr`   
  포인터도 변수기 때문에 초기화를 해주지 않으면 쓰레기 값이 들어있기 때문이다. 뜬금없이 이상한 공간을 가리키고 있을 수 있기 때문에..

### \<cstddef> 의 `std::nullptr_t`

```cpp
std::nullptr_t nptr; // 변수 nptr 은 nullptr만 대입될 수 있다.
```

\<csstddef> 라이브러리는 std::nullptr_t 타입을 지원하는데 이 타입의 변수는 nullptr만 담을 수 있다. 


***
<br>

    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}